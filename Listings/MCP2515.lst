C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MCP2515
OBJECT MODULE PLACED IN .\Objects\MCP2515.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MCP2515.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\MCP2515.lst) TABS(2) OBJECT(.\Objects\MCP2515.obj)

line level    source

   1          /**********************************************************************************
   2           * ļ  MCP2515.c
   3           *     MCP2515         
   4           * ʵƽ̨NiRen_STC/IAP15İ(ûSTC15Ƭ) + NiRen_MCP2515 CANģ    
   5          **********************************************************************************/
   6          
   7          #include <reg51.h>
   8          #include "MCP2515.H"
   9          
  10          //MCP2515Ŷ
  11          sbit MCP2515_INT  = P1^6;//MCP2515ж    ûõ
  12          
  13          sbit MCP2515_SCK  = P1^5;//SPIʱ 
  14          sbit MCP2515_MOSI = P1^4;//SPIӻ 
  15          sbit MCP2515_MISO = P1^3;//SPIӻ 
  16          sbit MCP2515_CS   = P1^2;//SPIƬѡ
  17          
  18          //uint8 code TXB0_Address[]={TXB0CTRL,TXB0SIDH,TXB0SIDL,TXB0EID8,TXB0EID0,TXB0DLC,TXB0D0,TXB0D1,TXB0D2,TXB
             -0D3,TXB0D4,TXB0D5,TXB0D6,TXB0D7};
  19          //uint8 code TXB1_Address[]={TXB1CTRL,TXB1SIDH,TXB1SIDL,TXB1EID8,TXB1EID0,TXB1DLC,TXB1D0,TXB1D1,TXB1D2,TXB
             -1D3,TXB1D4,TXB1D5,TXB1D6,TXB1D7};
  20          //uint8 code TXB2_Address[]={TXB2CTRL,TXB2SIDH,TXB2SIDL,TXB2EID8,TXB2EID0,TXB2DLC,TXB2D0,TXB2D1,TXB2D2,TXB
             -2D3,TXB2D4,TXB2D5,TXB2D6,TXB2D7};
  21          //
  22          //uint8 code RXF0_Address[]={RXF0SIDH,RXF0SIDL,RXF0EID8,RXF0EID0};
  23          //uint8 code RXF1_Address[]={RXF1SIDH,RXF1SIDL,RXF1EID8,RXF1EID0};
  24          //uint8 code RXF2_Address[]={RXF2SIDH,RXF2SIDL,RXF2EID8,RXF2EID0};
  25          //uint8 code RXF3_Address[]={RXF3SIDH,RXF3SIDL,RXF3EID8,RXF3EID0};
  26          //uint8 code RXF4_Address[]={RXF4SIDH,RXF4SIDL,RXF4EID8,RXF4EID0};
  27          //uint8 code RXF5_Address[]={RXF5SIDH,RXF5SIDL,RXF5EID8,RXF5EID0};
  28          //
  29          //uint8 code RXM0_Address[]={RXM0SIDH,RXM0SIDL,RXM0EID8,RXM0EID0};
  30          //uint8 code RXM1_Address[]={RXM1SIDH,RXM1SIDL,RXM1EID8,RXM1EID0};
  31          
  32          /*******************************************************************************
  33          *   : Delay_Nms
  34          *     : ͨʱԼnms(׼ȷ)
  35          *     : x
  36          * ˵    : ˷ʽʱʱǲ׼ȷ,׼ȷʱöʱ
  37          *******************************************************************************/
  38          void Delay_Nms(uint16 x)
  39          {
  40   1        uint16 y;
  41   1      
  42   1        for (;x>0;x--)
  43   1          for (y=0;y<100;y++);
  44   1      }
  45          
  46          /*******************************************************************************
  47          *   : SPI_ReadByte
  48          *     : ͨSPIȡһֽ
  49          *     : 
  50          *     : 
  51          * ֵ  : rByte(ȡһֽ)
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 2   

  52          * ˵    : 
  53          *******************************************************************************/
  54          uint8 SPI_ReadByte(void)
  55          {
  56   1        uint8 i,rByte=0;
  57   1        
  58   1        MCP2515_SCK=0;
  59   1        for(i=0;i<8;i++)
  60   1        {
  61   2          MCP2515_SCK=1;
  62   2          rByte<<=1;
  63   2          rByte|=MCP2515_MISO;
  64   2          MCP2515_SCK=0;  
  65   2        }
  66   1        return rByte;
  67   1      }
  68          
  69          /*******************************************************************************
  70          *   : SPI_SendByte
  71          *     : SPIһֽ
  72          *     : dt:͵
  73          *     : 
  74          * ֵ  : 
  75          * ˵    : 
  76          *******************************************************************************/
  77          void SPI_SendByte(uint8 dt)
  78          {
  79   1        uint8 i;
  80   1          
  81   1        for(i=0;i<8;i++)
  82   1        { 
  83   2          MCP2515_SCK=0;
  84   2          if((dt<<i)&0x80)
  85   2            MCP2515_MOSI=1;
  86   2          else
  87   2            MCP2515_MOSI=0;         
  88   2          MCP2515_SCK=1;
  89   2        }
  90   1        MCP2515_SCK=0;
  91   1      }
  92          
  93          /*******************************************************************************
  94          *   : MCP2515_WriteByte
  95          *     : ͨSPIMCP2515ַָĴд1ֽ
  96          *     : addr:MCP2515Ĵַ,dat:д
  97          *     : 
  98          * ֵ  : 
  99          * ˵    : 
 100          *******************************************************************************/
 101          void MCP2515_WriteByte(uint8 addr,uint8 dat)
 102          {
 103   1        MCP2515_CS=0;       //MCP2515CSΪ͵ƽ
 104   1        SPI_SendByte(CAN_WRITE);  //д
 105   1        SPI_SendByte(addr);     //͵ַ
 106   1        SPI_SendByte(dat);      //д
 107   1        MCP2515_CS=1;       //MCP2515CSΪߵƽ 
 108   1      }
 109          
 110          /*******************************************************************************
 111          *   : MCP2515_ReadByte
 112          *     : ͨSPIMCP2515ַָ1ֽ
 113          *     : addr:MCP2515Ĵַ
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 3   

 114          *     : 
 115          * ֵ  : rByte:ȡĴ1ֽ
 116          * ˵    : 
 117          *******************************************************************************/
 118          uint8 MCP2515_ReadByte(uint8 addr)
 119          {
 120   1        uint8 rByte;
 121   1        
 122   1        MCP2515_CS=0;       //MCP2515CSΪ͵ƽ
 123   1        SPI_SendByte(CAN_READ);   //Ͷ
 124   1        SPI_SendByte(addr);     //͵ַ
 125   1        rByte=SPI_ReadByte();   //ȡ
 126   1        MCP2515_CS=1;       //MCP2515CSΪߵƽ
 127   1        return rByte;       //ضһֽ
 128   1      }
 129          
 130          /*******************************************************************************
 131          *   : MCP2515_Reset
 132          *     : ͸λָλMCP2515
 133          *     : 
 134          *     : 
 135          * ֵ  : 
 136          * ˵    : ڲĴλΪȱʡ״̬,趨Ϊģʽ
 137          *******************************************************************************/
 138          void MCP2515_Reset(void)
 139          {
 140   1        MCP2515_CS=0;       //MCP2515CSΪ͵ƽ
 141   1        SPI_SendByte(CAN_RESET);  //ͼĴλ
 142   1        MCP2515_CS=1;       //MCP2515CSΪߵƽ
 143   1      }
 144          
 145          /*******************************************************************************
 146          *     : ƴӳIDĬλĵһλΪչ־λ
 147          *     : array飬 offsetIDλ
 148          *******************************************************************************/
 149          uint32 Get_ID_For_Array(uint8 *array, uint8 offset) {
 150   1          return ((uint32) array[0 + offset] & 0x7F << 24)
 151   1          | (uint32) (array[1 + offset] << 24)
 152   1          | (uint32) (array[2 + offset] << 16)
 153   1          | array[3 + offset];
 154   1      }
 155          
 156          /*******************************************************************************
 157          *     : ID֣дУĬλĵһλΪչ־λ
 158          *     : array飬 offsetIDλдλã
 159          *******************************************************************************/
 160          void Set_Array_For_ID(uint8 *array, uint8 offset, uint32 ID, uint8 EXIDE) {
 161   1          array[0 + offset] = (ID >> 24) | (EXIDE << 7);
 162   1          array[1 + offset] = (ID >> 16) & 0xFF;
 163   1          array[2 + offset] = (ID >> 8) & 0xFF;
 164   1          array[3 + offset] = ID & 0xFF;
 165   1      }
 166          
 167          /*******************************************************************************
 168          *     : mcp2515ĴжȡƴӳIDչ־λΪIDλ
 169          *     : buf_addrmcp2515ĴSIDHĵַ
 170          *******************************************************************************/
 171          uint32 Get_ID_For_Buf(uint8 buf_addr) {
 172   1          uint8 SIDL = MCP2515_ReadByte(buf_addr + 1);
 173   1      
 174   1          uint32 SID = ((uint32) MCP2515_ReadByte(buf_addr) << 3) | (SIDL >> 5);
 175   1          uint32 EID = (uint32) (SIDL & 3) << 16
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 4   

 176   1                  | ((uint32) MCP2515_ReadByte(buf_addr + 2) << 8)
 177   1                  | MCP2515_ReadByte(buf_addr + 3);
 178   1          // EIDֵչ֡
 179   1          if (EID || (SIDL & 0x8)) {
 180   2              return SID << 18 | EID;
 181   2          } else {
 182   2              return SID;
 183   2          }
 184   1      }
 185          
 186          /*******************************************************************************
 187          *     : IDд뵽mcp2515Ĵ
 188          *     : buf_addrmcp2515ĴSIDHĵַ ID Լչ־λ
 189          *******************************************************************************/
 190          void Set_Buf_For_ID(uint8 buf_addr, uint32 ID, uint8 EXIDE) {
 191   1          if ((ID > 0x7FF) || EXIDE) {
 192   2              MCP2515_WriteByte(buf_addr, ID >> 21);               //SIDH
 193   2              MCP2515_WriteByte(buf_addr + 1, (ID >> 18 & 0x07) << 5 | (ID >> 16 & 0x03) | 0x08);      //SIDL
 194   2              MCP2515_WriteByte(buf_addr + 2, ID >> 8 & 0xFF);     //EID8
 195   2              MCP2515_WriteByte(buf_addr + 3, ID & 0xFF);          //EID0
 196   2          } else {
 197   2              MCP2515_WriteByte(buf_addr, ID >> 3);                //SIDH
 198   2              MCP2515_WriteByte(buf_addr + 1, (ID & 0x07) << 5);   //SIDL
 199   2              MCP2515_WriteByte(buf_addr + 2, 0);                  //EID8
 200   2              MCP2515_WriteByte(buf_addr + 3, 0);                  //EID0
 201   2          }
 202   1      }
 203          
 204          /*******************************************************************************
 205          *     : ñ
 206          * ˵    : MCP2515 ݮص㣬ҪFOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=
             -1..4
 207          *******************************************************************************/
 208          void Set_Bitrate_Array(uint8 _5Kbps, uint8 *bitrate) {
 209   1          uint8 kbps, prseg, phseg1, phseg2, sjw;
 210   1          switch (_5Kbps * 5) {
 211   2              case 5:
 212   2                  kbps = CAN_5Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 213   2                  break;
 214   2              case 10:
 215   2                  kbps = CAN_10Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 216   2                  break;
 217   2              case 25:
 218   2                  kbps = CAN_25Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 219   2                  break;
 220   2              case 50:
 221   2                  kbps = CAN_50Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 222   2                  break;
 223   2              case 100:
 224   2                  kbps = CAN_100Kbps, prseg = PRSEG_8TQ, phseg1 = PHSEG1_8TQ, phseg2 = PHSEG2_3TQ, sjw = SJW_1TQ
             -;
 225   2                  break;
 226   2              case 125:
 227   2                  kbps = CAN_125Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
             -;
 228   2                  break;
 229   2              case 250:
 230   2                  kbps = CAN_250Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
             -;
 231   2                  break;
 232   2              default : /* Ĭȡ500Kbps */
 233   2                  kbps = CAN_500Kbps, prseg = PRSEG_2TQ, phseg1 = PHSEG1_3TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 5   

             -;
 234   2          }
 235   1          bitrate[0] = kbps, bitrate[1] = prseg, bitrate[2] = phseg1, bitrate[3] = phseg2, bitrate[4] = sjw;
 236   1      }
 237          
 238          
 239          
 240          /*******************************************************************************
 241          *     : ñĽRXM͹RXFͻTXB ID
 242          *     :  SIDH׵ַ ID չ־λ
 243          * ֵ  : 
 244          * ˵    : ID>0x7FFΪչ֡
 245          *******************************************************************************/
 246          //void CanSetID(uint8 Address, uint32 ID, bool EXIDE)
 247          //{
 248          //    // EXIDE=1ID>0x7FFλչ֡
 249          //    if ((ID > 0x7FF) || EXIDE) {
 250          //        MCP2515_WriteByte(Address, ID >> 21);                      //SIDH
 251          //        MCP2515_WriteByte(Address + 1, (ID >> 18 & 0x07) << 5 | (ID >> 16 & 0x03) | 0x08);      //SIDL
 252          //        MCP2515_WriteByte(Address + 2, ID >> 8 & 0xFF);      //EID8
 253          //        MCP2515_WriteByte(Address + 3, ID & 0xFF);           //EID0
 254          //    } else {
 255          //        MCP2515_WriteByte(Address, ID >> 3);                      //SIDH
 256          //        MCP2515_WriteByte(Address + 1, (ID & 0x07) << 5);   //SIDL
 257          //        MCP2515_WriteByte(Address + 2, 0);                  //EID8
 258          //        MCP2515_WriteByte(Address + 3, 0);                  //EID0
 259          //    }
 260          //}
 261          
 262          void Can_Init(CanCfgStruct *CanCfg)
 263          {
 264   1          MCP2515_Reset();    //͸λָλMCP2515
 265   1          Delay_Nms(1);        //ͨʱԼnms(׼ȷ)
 266   1      
 267   1          // ò
 268   1          // set CNF1, SJW=00,Ϊ1TQ, BRP=49, TQ=[2*(BRP+1)]/Fsoc=2*50/8M=12.5us
 269   1          MCP2515_WriteByte(CNF1, CanCfg->bitrate[4] | CanCfg->bitrate[0]);
 270   1          // set CNF2, SAM=0,ڲ߽һβPHSEG1=(2+1)TQ=3TQ, PRSEG=(0+1)TQ=1TQ
 271   1          MCP2515_WriteByte(CNF2, BTLMODE_CNF3 | CanCfg->bitrate[2] | CanCfg->bitrate[1]);
 272   1          // set CNF3, PHSEG2=(2+1)TQ=3TQ,ͬʱCANCTRL.CLKEN=1ʱ趨CLKOUTΪʱʹλ
 273   1          MCP2515_WriteByte(CNF3, SOF_ENABLED | CanCfg->bitrate[3]);
 274   1      
 275   1          MCP2515_WriteByte(RXB0CTRL, CanCfg->BUKT_enable << 2);  // RXB0,RXB0 յıĽRXB1
 276   1      
 277   1          MCP2515_WriteByte(RXB1CTRL, RXM);  // б
 278   1      
 279   1          MCP2515_WriteByte(CANINTF, CanCfg->CANINTF_enable);  // CANжϱ־Ĵλ(MCU)
 280   1          MCP2515_WriteByte(CANINTE, CanCfg->CANINTE_enable);  // CANжʹܼĴĽջ0жʹ,
             -λֹж
 281   1      
 282   1          // ˲
 283   1          Set_Buf_For_ID(RXF0SIDH, CanCfg->RXF0ID, CanCfg->RXF0IDE);
 284   1          Set_Buf_For_ID(RXF1SIDH, CanCfg->RXF1ID, CanCfg->RXF1IDE);
 285   1          Set_Buf_For_ID(RXF2SIDH, CanCfg->RXF2ID, CanCfg->RXF2IDE);
 286   1          Set_Buf_For_ID(RXF3SIDH, CanCfg->RXF3ID, CanCfg->RXF3IDE);
 287   1          Set_Buf_For_ID(RXF4SIDH, CanCfg->RXF4ID, CanCfg->RXF4IDE);
 288   1          Set_Buf_For_ID(RXF5SIDH, CanCfg->RXF5ID, CanCfg->RXF5IDE);
 289   1          // 
 290   1          Set_Buf_For_ID(RXM0SIDH, CanCfg->RXM0ID, 1);
 291   1          Set_Buf_For_ID(RXM1SIDH, CanCfg->RXM1ID, 1);
 292   1      
 293   1          MCP2515_WriteByte(CANCTRL, REQOP_LOOPBACK | CLKOUT_ENABLED);//MCP2515Ϊģʽ,˳ģʽ
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 6   

 294   1          if (OPMODE_NORMAL != (MCP2515_ReadByte(CANSTAT) && 0xE0))//жMCP2515ǷѾ뻷ģʽ
 295   1          {
 296   2              MCP2515_WriteByte(CANCTRL, REQOP_LOOPBACK | CLKOUT_ENABLED);//ٴνMCP2515Ϊģʽ,˳
             -ģʽ
 297   2          }
 298   1      }
 299          
 300          /*******************************************************************************
 301          *   : MCP2515_Init
 302          *     : MCP2515ʼ
 303          *     : 
 304          *     : 
 305          * ֵ  : 
 306          * ˵    : ʼλáʶõȡ
 307          *******************************************************************************/
 308          //void MCP2515_Init(uint8 *CAN_Bitrate)
 309          //{
 310          //  uint8 temp=0;
 311          //
 312          //  MCP2515_Reset();  //͸λָλMCP2515
 313          //  Delay_Nms(1);   //ͨʱԼnms(׼ȷ)
 314          //
 315          //  //ò
 316          //  //set CNF1,SJW=00,Ϊ1TQ,BRP=49,TQ=[2*(BRP+1)]/Fsoc=2*50/8M=12.5us
 317          //  MCP2515_WriteByte(CNF1,CAN_Bitrate[4]|CAN_Bitrate[0]);
 318          //  //set CNF2,SAM=0,ڲ߽һβPHSEG1=(2+1)TQ=3TQ,PRSEG=(0+1)TQ=1TQ
 319          //  MCP2515_WriteByte(CNF2,BTLMODE_CNF3|CAN_Bitrate[2]|CAN_Bitrate[1]);
 320          //  //set CNF3,PHSEG2=(2+1)TQ=3TQ,ͬʱCANCTRL.CLKEN=1ʱ趨CLKOUTΪʱʹλ
 321          //  MCP2515_WriteByte(CNF3,SOF_ENABLED|CAN_Bitrate[3]);
 322          //
 323          //  MCP2515_WriteByte(RXB0CTRL,0x06);//RXB0,RXB0 յıĽRXB1
 324          //
 325          //  //uint8 RXF_Address,uint32 ID,uint8 EXIDE)
 326          //  //RXB0 ջ䱸˲ĴRXF0 RXF1ԼμĴRXM0
 327          //  Set_Buf_For_ID(RXF0SIDH,0x100,1);
 328          //  Set_Buf_For_ID(RXF1SIDH,0x7FE,0);
 329          //
 330          //  Set_Buf_For_ID(RXM0SIDH,0x7FF,0);
 331          //
 332          //  //RXB1 䱸˲ĴRXF2RXF3RXF4RXF5˲μĴRXM1
 333          //  Set_Buf_For_ID(RXF2SIDH,0x800,1);
 334          //  Set_Buf_For_ID(RXF3SIDH,0x1FFFFFFF,1);
 335          //  Set_Buf_For_ID(RXF4SIDH,0x7FF,0);
 336          //  Set_Buf_For_ID(RXF5SIDH,0x0,0);
 337          //
 338          //  Set_Buf_For_ID(RXM1SIDH,0x1FFFFFFE,0);
 339          //
 340          ////  MCP2515_WriteByte(TXB0SIDH,0xAB);//ͻ0׼ʶλ
 341          ////  MCP2515_WriteByte(TXB0SIDL,0xE0);//|0x08|0x2);//ͻ0׼ʶλ
 342          ////  MCP2515_WriteByte(TXB0EID8,0x00);//ͻ0׼ʶλ
 343          ////  MCP2515_WriteByte(TXB0EID0,0x00);//ͻ0׼ʶλ
 344          ////
 345          ////
 346          ////  MCP2515_WriteByte(RXB0SIDH,0x00);//սջ0ı׼ʶλ
 347          ////  MCP2515_WriteByte(RXB0SIDL,0x00);//սջ0ı׼ʶλ
 348          ////
 349          ////  MCP2515_WriteByte(RXB0CTRL,0x62);//ձ׼ʶЧϢ
 350          ////  MCP2515_WriteByte(RXB0DLC,DLC_8);//ýݵĳΪ8ֽ
 351          ////
 352          ////  MCP2515_WriteByte(RXF0SIDH,0xFF);       //˲Ĵn׼ʶλ
 353          ////
 354          ////  MCP2515_WriteByte(RXM0SIDH,0xFF);       //μĴn׼ʶλ
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 7   

 355          ////  MCP2515_WriteByte(RXM1EID0,0xE0);       //μĴn׼ʶλ
 356          ////
 357          //  MCP2515_WriteByte(CANINTF,0x00);    //CANжϱ־Ĵλ(MCU)
 358          //  MCP2515_WriteByte(CANINTE,0x03);    //CANжʹܼĴĽջжʹ,λֹж
 359          //
 360          ////  MCP2515_WriteByte(CANCTRL,REQOP_LOOPBACK|CLKOUT_ENABLED);//|OSM_ENABLEDMCP2515Ϊģʽ,˳
             -ģʽ
 361          ////
 362          ////  temp=MCP2515_ReadByte(CANSTAT);//ȡCAN״̬Ĵֵ
 363          ////  if(OPMODE_LOOPBACK!=(temp&&0xE0))//жMCP2515ǷѾģʽ
 364          ////  {
 365          ////      MCP2515_WriteByte(CANCTRL,REQOP_LOOPBACK|CLKOUT_ENABLED);//|OSM_ENABLEDٴνMCP2515Ϊģ
             -,˳ģʽ
 366          ////  }
 367          //
 368          //    MCP2515_WriteByte(CANCTRL,REQOP_LOOPBACK|CLKOUT_ENABLED);//MCP2515Ϊģʽ,˳ģʽ
 369          //
 370          //    temp=MCP2515_ReadByte(CANSTAT);//ȡCAN״̬Ĵֵ
 371          //    if(OPMODE_NORMAL!=(temp&&0xE0))//жMCP2515ǷѾ뻷ģʽ
 372          //    {
 373          //    MCP2515_WriteByte(CANCTRL,REQOP_LOOPBACK|CLKOUT_ENABLED);//ٴνMCP2515Ϊģʽ,˳ģʽ
 374          //    }
 375          //
 376          //}
 377          
 378          /*******************************************************************************
 379          *   : CAN_Send_Buffer
 380          *     : CANָȵ
 381          *     : *CAN_TX_Buf(ݻָ),len(ݳ)
 382          *     : 
 383          * ֵ  : 
 384          * ˵    :
 385          * Ľ   ڱķ֮ǰ MCU ӦCANINTE.TXInE λгʼԱڱķʱʹֹܻжϵĲ
 386           *          д뷢ͻ֮ǰ뽫TXBnCTRL.TXREQ λ㣨ͻ޵ȴ͵ıģ
 387          *******************************************************************************/
 388          void CAN_Send_Msg(MsgStruct *SendMsg) {
 389   1          uint8 TXBnCTRL;         // ѡͻ
 390   1          uint8 i;
 391   1          //Ĵ״̬ȡTXB0-2Ƿæµ1Ϊæµ0ΪУ ǰĴȫæµ Ĭʹõ3
 392   1          for (i = 0; i < 3; i++) //ֱַ0Ž
 393   1          {
 394   2              TXBnCTRL = TXB0CTRL + 0xF * i;
 395   2              if ((MCP2515_ReadByte(TXBnCTRL) & TXREQ) == 0) {
 396   3                  break;
 397   3              }
 398   2          }
 399   1      
 400   1          Set_Buf_For_ID(TXBnCTRL + 1, SendMsg->ID, SendMsg->EXIDE);
 401   1      
 402   1          // DLC ĬΪ֡ RTR=0   ڿԶ֡
 403   1          MCP2515_WriteByte(TXBnCTRL + 5, SendMsg->DLC | (SendMsg->RTR << 6));
 404   1      
 405   1          for(i = 0;(i <= SendMsg->DLC && i <= 8); i++)
 406   1          {
 407   2              MCP2515_WriteByte(TXBnCTRL + 6 + i, SendMsg->DATA[i]);              //D0_8͵д뷢ͻĴ
             -
 408   2          }
 409   1      
 410   1          MCP2515_CS=0;
 411   1          MCP2515_WriteByte(TXBnCTRL, TXREQ | SendMsg->LEVEL);  //CTRL ʼ
 412   1          MCP2515_CS=1;
 413   1          // ʽãηͣԶ֡չ֡״̬Ӧ
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 8   

 414   1      
 415   1          // ȴķͳɹ
 416   1      //    for(i = 0; i < 14; i++)
 417   1      //    {
 418   1      //        if ((MCP2515_ReadByte(TXBnCTRL) & TXREQ) == 0)
 419   1      //        {
 420   1      //            return;
 421   1      //        }
 422   1      //        Delay_Nms(100);
 423   1      //    }
 424   1      }
 425          
 426          //
 427          //void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data)
 428          //{
 429          //  uint8 TXBnCTRL;         // ѡͻ
 430          //
 431          //    uint8 i;
 432          //    //Ĵ״̬ȡTXB0-2Ƿæµ1Ϊæµ0ΪУ ǰĴȫæµ Ĭʹõ3
 433          //  for (i = 0; i < 3; i++) //ֱַ0Ž
 434          //    {
 435          //      TXBnCTRL = TXB0CTRL + 0xF * i;
 436          //      if ((MCP2515_ReadByte(TXBnCTRL) & TXREQ) == 0)
 437          //      {
 438          //            break;
 439          //      }
 440          //    }
 441          ////  uint8 Read_TXBnCTRL = MCP2515_ReadByte(TXB0CTRL);
 442          ////  if ((Read_TXBnCTRL & TXREQ) == 0)
 443          ////  {
 444          ////      TXBnCTRL = TXB0CTRL;
 445          ////  }
 446          ////  else
 447          ////  {
 448          ////      Read_TXBnCTRL = MCP2515_ReadByte(TXB1CTRL);
 449          ////      if ((Read_TXBnCTRL & TXREQ) == 0)
 450          ////      {
 451          ////          TXBnCTRL = TXB1CTRL;
 452          ////      }
 453          ////      else
 454          ////      {
 455          ////          Read_TXBnCTRL = MCP2515_ReadByte(TXB2CTRL);  // ǰĴȫæµ Ĭʹõ3
 456          ////          TXBnCTRL = TXB2CTRL;
 457          ////      }
 458          ////  }
 459          //
 460          //  // DLC ĬΪ֡ RTR=0   ڿԶ֡
 461          //  MCP2515_WriteByte(TXBnCTRL + 5, DLC);
 462          //    Set_Buf_For_ID(TXBnCTRL + 1, ID, EXIDE);
 463          //  // EXIDE=1ID>0x7FFչ֡
 464          ////  if (ID<=0x7FF)
 465          ////  {
 466          ////    if (EXIDE)
 467          ////    {
 468          ////        MCP2515_WriteByte(TXBnCTRL + 1, 0x0);     //SIDH
 469          ////        MCP2515_WriteByte(TXBnCTRL + 2, 0x8);     //SIDL
 470          ////        MCP2515_WriteByte(TXBnCTRL + 3, ID>>8&0xFF);  //EID8
 471          ////            MCP2515_WriteByte(TXBnCTRL + 4, ID&0xFF);   //EID0
 472          ////    }
 473          ////    else
 474          ////    {
 475          ////        MCP2515_WriteByte(TXBnCTRL + 1, ID>>3);     //SIDH
C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 9   

 476          ////        MCP2515_WriteByte(TXBnCTRL + 2, (ID&0x07)<<5);  //SIDL
 477          ////        MCP2515_WriteByte(TXBnCTRL + 3, 0);       //EID8
 478          ////        MCP2515_WriteByte(TXBnCTRL + 4, 0);       //EID0
 479          ////    }
 480          ////  }
 481          ////  else
 482          ////  {
 483          ////      MCP2515_WriteByte(TXBnCTRL + 1, ID>>21);                  //SIDH
 484          ////      MCP2515_WriteByte(TXBnCTRL + 2, (ID>>18&0x07)<<5|(ID>>16&0x03)|0x08);   //SIDL
 485          ////      MCP2515_WriteByte(TXBnCTRL + 3, ID>>8&0xFF);                //EID8
 486          ////      MCP2515_WriteByte(TXBnCTRL + 4, ID&0xFF);                 //EID0
 487          ////  }
 488          //
 489          //  for(i = 0;(i <= DLC && i <= 8); i++)
 490          //  {
 491          //      MCP2515_WriteByte(TXBnCTRL + 6 + i, Send_data[i]);              //D0_8͵д뷢ͻĴ
 492          //  }
 493          //
 494          //  MCP2515_CS=0;
 495          //  MCP2515_WriteByte(TXBnCTRL, Read_TXBnCTRL | TXREQ); //CTRL ʼ
 496          //  MCP2515_CS=1;
 497          //  //ʽãηͣԶ֡չ֡״̬Ӧ
 498          //
 499          //    // ȴķͳɹ
 500          //    for(i = 0; i < 14; i++)
 501          //    {
 502          //        if ((MCP2515_ReadByte(TXBnCTRL) & TXREQ) == 0)
 503          //        {
 504          //            return;
 505          //        }
 506          //        Delay_Nms(100);
 507          //    }
 508          //}
 509          
 510          /*******************************************************************************
 511          *   : CAN_Receive_Buffer
 512          *     : CANһ֡
 513          *     : RX_Address(ҪȡRXB0CTRLRXB1CTRLַ),*CAN_TX_Buf(ݻָ)
 514          *     : 
 515          * ֵ  : len(յݵĳ,0~8ֽ)
 516          * ˵    : 
 517          *******************************************************************************/
 518          //void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf)
 519          //{
 520          //  uint8 j;
 521          //  for(j=0;j<14;j++)
 522          //  {
 523          //    CAN_RX_Buf[j]=MCP2515_ReadByte(RXB_CTRL_Address+j);//CANյݷָ
 524          //    //CAN_RX_Buf[j]=RXB_CTRL_Address+j;
 525          //  }
 526          //  if (RXB_CTRL_Address==RXB0CTRL)
 527          //    {
 528          //    MCP2515_WriteByte(CANINTF,0);//жϱ־λ(жϱ־ĴMCU)
 529          //    }
 530          //  else if (RXB_CTRL_Address==RXB1CTRL)
 531          //    {
 532          //    MCP2515_WriteByte(CANINTF,0);//жϱ־λ(жϱ־ĴMCU)
 533          //    }
 534          //}
 535          
 536          

C51 COMPILER V9.60.0.0   MCP2515                                                           11/20/2021 20:05:40 PAGE 10  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2087    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      45
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
