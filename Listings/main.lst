C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //ÉùÃ÷º¯Êý
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_WriteByte(uint8 addr,uint8 dat);
  15          extern void MCP2515_Init(uint8 *CAN_Bitrate);
  16          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  17          extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  18          
  19          
  20          bool CAN_MERRF_Flag = 0;                            //CAN±¨ÎÄ´íÎóÖÐ¶Ï±êÖ¾Î»
  21          bool CAN_WAKIF_Flag = 0;                            //CAN»½ÐÑÖÐ¶Ï±êÖ¾Î»
  22          bool CAN_ERRIF_Flag = 0;                            //CAN´íÎóÖÐ¶Ï±êÖ¾Î»£¨EFLG ¼Ä´æÆ÷ÖÐÓÐ¶à¸öÖÐ¶ÏÔ´£©
  23          bool CAN_TX2IF_Flag = 0;                            //MCP2515·¢ËÍ»º³åÆ÷2 ¿ÕÖÐ¶Ï±êÖ¾Î»
  24          bool CAN_TX1IF_Flag = 0;                            //MCP2515·¢ËÍ»º³åÆ÷1 ¿ÕÖÐ¶Ï±êÖ¾Î»
  25          bool CAN_TX0IF_Flag = 0;                            //MCP2515·¢ËÍ»º³åÆ÷0 ¿ÕÖÐ¶Ï±êÖ¾Î»
  26          bool CAN_RX1IF_Flag = 0;                            //MCP2515½ÓÊÕ»º³åÆ÷1 ÂúÖÐ¶Ï±êÖ¾Î»
  27          bool CAN_RX0IF_Flag = 0;                            //MCP2515½ÓÊÕ»º³åÆ÷0 ÂúÖÐ¶Ï±êÖ¾Î»
  28          
  29          
  30          
  31          char putchar(char c)  //printfº¯Êý»áµ÷ÓÃputchar()
  32          {
  33   1          UART_send_str(c);
  34   1          return c;
  35   1      }
  36          
  37          //MCP2515²¨ÌØÂÊ Òª¿¼ÂÇFOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
  38          uint8 code bitrate_5Kbps[5]={ CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  39          uint8 code bitrate_10Kbps[5]={ CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  40          uint8 code bitrate_25Kbps[5]={ CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  41          uint8 code bitrate_50Kbps[5]={CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  42          uint8 code bitrate_100Kbps[5]={CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
  43          uint8 code bitrate_125Kbps[5]={CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  44          uint8 code bitrate_250Kbps[5]={CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  45          uint8 code bitrate_500Kbps[5]={CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
  46          
  47          /*******************************************************************************
  48          * º¯ÊýÃû  : Exint_Init
  49          * ÃèÊö    : Íâ²¿ÖÐ¶Ï1³õÊ¼»¯º¯Êý
  50          * ÊäÈë    : ÎÞ
  51          * Êä³ö    : ÎÞ
  52          * ·µ»ØÖµ  : ÎÞ
  53          * ËµÃ÷    : ÎÞ
  54          *******************************************************************************/
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 2   

  55          void Exint_Init(void) {
  56   1          PX1 = 1;        //ÉèÖÃÍâ²¿ÖÐ¶Ï1µÄÖÐ¶ÏÓÅÏÈ¼¶Îª¸ßÓÅÏÈ¼¶
  57   1          IT1 = 1;    //ÉèÖÃINT1µÄÖÐ¶ÏÀàÐÍ (1:½öÏÂ½µÑØ 0:ÉÏÉýÑØºÍÏÂ½µÑØ)
  58   1          EX1 = 1;    //Ê¹ÄÜINT1ÖÐ¶Ï
  59   1          EA = 1;    //Ê¹ÄÜ×ÜÖÐ¶Ï
  60   1      }
  61          
  62          /*******************************************************************************
  63          * º¯ÊýÃû  : Exint_ISR
  64          * ÃèÊö    : Íâ²¿ÖÐ¶Ï1ÖÐ¶Ï·þÎñº¯Êý µ¥Æ¬»úÒý½ÅP3.3½ÓMCP2515 INTÒý½Å
  65          * ÊäÈë    : ÎÞ
  66          * Êä³ö    : ÎÞ
  67          * ·µ»ØÖµ  : ÎÞ
  68          * ËµÃ÷    : ÓÃÓÚ¼ì²âMCP2515ÖÐ¶ÏÒý½ÅµÄÖÐ¶ÏÐÅºÅ
  69          *******************************************************************************/
  70          void Exint_ISR(void) interrupt 2 using 1
  71          {
  72   1          uint8 Flag;                                //CAN½ÓÊÕµ½Êý¾Ý±êÖ¾
  73   1          Flag = MCP2515_ReadByte(CANINTF);
  74   1      
  75   1          if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN±¨ÎÄ´íÎóÖÐ¶Ï±êÖ¾Î»
  76   1          if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN»½ÐÑÖÐ¶Ï±êÖ¾Î»
  77   1          if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN´íÎóÖÐ¶Ï±êÖ¾Î»£¨EFLG ¼Ä´æÆ÷ÖÐÓÐ¶à¸ö
             -ÖÐ¶ÏÔ´£©
  78   1          if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515·¢ËÍ»º³åÆ÷2 ¿ÕÖÐ¶Ï±êÖ¾Î»
  79   1          if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515·¢ËÍ»º³åÆ÷1 ¿ÕÖÐ¶Ï±êÖ¾Î»
  80   1          if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515·¢ËÍ»º³åÆ÷0 ¿ÕÖÐ¶Ï±êÖ¾Î»
  81   1          if (Flag&0x02) CAN_RX1IF_Flag = 1;                            //MCP2515½ÓÊÕ»º³åÆ÷1 ÂúÖÐ¶Ï±êÖ¾Î»
  82   1          if (Flag&0x01) CAN_RX0IF_Flag = 1;                           //MCP2515½ÓÊÕ»º³åÆ÷0 ÂúÖÐ¶Ï±êÖ¾Î»
  83   1      }
  84          
  85          uint8 *NumToStr(uint16 num, uint8 radix) {
  86   1          static char str[8];      //±ØÐëÎªstatic±äÁ¿£¬»òÕßÊÇÈ«¾Ö±äÁ¿
  87   1      
  88   1          uint8 tmp;
  89   1          uint8 i = 0;
  90   1          uint8 j = 0;
  91   1          uint8 NewStr[8] = {0};
  92   1      
  93   1          do      //´Ó¸÷Î»¿ªÊ¼±äÎª×Ö·û£¬Ö±µ½×î¸ßÎ»£¬×îºóÓ¦¸Ã·´×ª
  94   1          {
  95   2              tmp = num % radix;
  96   2              num = num / radix;
  97   2              NewStr[i++] = tmp;
  98   2          } while (num > 0);
  99   1          do      //´Ó¸÷Î»¿ªÊ¼±äÎª×Ö·û£¬Ö±µ½×î¸ßÎ»£¬×îºóÓ¦¸Ã·´×ª
 100   1          {
 101   2              tmp = NewStr[--i];
 102   2              if (tmp <= 9)              // ×ª»»Îª 0-9 »ò A-F
 103   2                  str[j++] = tmp + '0';
 104   2              else
 105   2                  str[j++] = tmp - 10 + 'A';
 106   2          } while (i > 0);
 107   1          str[j] = '\0';                 // Ìí¼Ó×Ö·û´®½áÊø·û
 108   1          return str;
 109   1      }
 110          
 111          uint8 i;
 112          ///* ½«ÐèÒª·¢ËÍµÄÊý¾Ý ×ª·¢µ½uart */
 113          //void Send(uint16 ID, uint8 EXIDE, uint8 DLC, uint8 *Send_data) {
 114          //    if (EXIDE)
 115          //    {
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 3   

 116          //        printf("Can send ID: %08X,  DLC:%bx,  Data: ", ID, DLC);
 117          //    }
 118          //    else
 119          //    {
 120          //        printf("Can send ID: %8X,  DLC:%bx,  Data: ", ID, DLC);
 121          //    }
 122          //
 123          //    for( i=0;i<DLC;i++ )
 124          //    {
 125          //        printf("%02bX " , Send_data[i]);
 126          //    }
 127          //    printf("\r\n");
 128          //    CAN_Send_buffer(ID, EXIDE, DLC, Send_data);
 129          //}
 130          
 131          void ShowMsg(MsgStruct *Msg)
 132          {
 133   1          uint8 i;
 134   1          uint32 ID = Msg->ID;
 135   1          uint8 EXIDE = Msg->EXIDE;
 136   1          uint8 DLC = Msg->DLC;
 137   1      
 138   1          if (Msg->IsSend)
 139   1          {
 140   2              printf("Can send    ");
 141   2          } else {
 142   2              printf("Can recevie ");
 143   2          }
 144   1      
 145   1          if (EXIDE)
 146   1          {
 147   2              printf("ID: %07lX,  DLC:%bx,  Data: ", ID, DLC);
 148   2          }
 149   1          else
 150   1          {
 151   2              printf("ID: %7lX,  DLC:%bx,  Data: ", ID, DLC);
 152   2          }
 153   1      
 154   1          for( i=0;i<DLC;i++ )
 155   1          {
 156   2              printf("%02bX " , Msg->DATA[i]);
 157   2          }
 158   1      
 159   1          printf("\r\n");
 160   1      }
 161          
 162          /* ½«ÐèÒª·¢ËÍµÄÊý¾Ý ×ª·¢µ½uart */
 163          void Send(MsgStruct *SendMsg) {
 164   1          uint32 ID = SendMsg->ID;
 165   1          uint8 EXIDE = SendMsg->EXIDE;
 166   1          uint8 DLC = SendMsg->DLC;
 167   1      //    ShowMsg(SendMsg);
 168   1          CAN_Send_buffer(ID, EXIDE, DLC, SendMsg->DATA);
 169   1      }
 170          
 171          ///* ½«ÐèÒª·¢ËÍµÄÊý¾Ý ×ª·¢µ½uart, CAN_RX_Buf[14]*/
 172          //void Receive(uint8 RXB_CTRL_Address, uint8 *CAN_RX_Buf) {
 173          //    uint8 i;
 174          //    uint8 Receive_DLC = 0;
 175          //    uint8 Read_RXB_CTRL = 0;
 176          //    uint8 Receive_data[8] = {0};
 177          //
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 4   

 178          //    CAN_Receive_Buffer(RXB_CTRL_Address, CAN_RX_Buf);//CAN½ÓÊÕÒ»Ö¡Êý¾Ý
 179          //
 180          //    Receive_DLC = CAN_RX_Buf[5] & 0x0F; //»ñÈ¡½ÓÊÕµ½µÄÊý¾Ý³¤¶È
 181          //    printf("Receive RXB_CTRL_Address: %bX, DLC:%bx, Data:", RXB_CTRL_Address, Receive_DLC);
 182          //
 183          //    for (i = 0; i < Receive_DLC; i++) //»ñÈ¡½ÓÊÕµ½µÄÊý¾Ý
 184          //    {
 185          //        Receive_data[i] = CAN_RX_Buf[6 + i];
 186          //        printf("%02bX " , Receive_data[i]);
 187          //    }
 188          //    printf("\r\n");
 189          ////  »ñÈ¡½ÓÊÕ»º´æÆ÷¼°ÑéÊÕÂË²¨Æ÷£¬ ´ýÓÅ»¯
 190          //    Read_RXB_CTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 191          //    printf("Read_RXB_CTRL: %02bX,  RXF:%bX \r\n", Read_RXB_CTRL, Read_RXB_CTRL & 0x07);
 192          //}
 193          //
 194           /* ½«ÐèÒª·¢ËÍµÄÊý¾Ý ×ª·¢µ½uart, CAN_RX_Buf[14]*/
 195           void Receive(uint8 RXB_CTRL_Address, MsgStruct *RecMsg) {
 196   1           uint8 i;
 197   1      
 198   1           uint8 RXBnCTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 199   1           uint8 RXBnSIDH = MCP2515_ReadByte(RXB_CTRL_Address + 1);
 200   1           uint8 RXBnSIDL = MCP2515_ReadByte(RXB_CTRL_Address + 2);
 201   1           uint8 RXBnEID8 = MCP2515_ReadByte(RXB_CTRL_Address + 3);
 202   1           uint8 RXBnEID0 = MCP2515_ReadByte(RXB_CTRL_Address + 4);
 203   1           uint8 RXBnDLC  = MCP2515_ReadByte(RXB_CTRL_Address + 5);
 204   1      
 205   1           RecMsg->EXIDE = (RXBnSIDL & 0x8) >> 3;  // À©Õ¹±êÊ¶·û±êÖ¾Î» 1 = ÊÕµ½µÄ±¨ÎÄÊÇÀ©Õ¹Ö¡, 0 = ÊÕµ½µÄ±¨ÎÄÊÇ±
             -ê×¼Ö¡
 206   1           RecMsg->DLC = RXBnDLC & 0x0F;
 207   1      
 208   1           if (RecMsg->EXIDE)
 209   1           {
 210   2               uint32 SID = (RXBnSIDH<<3) | (RXBnSIDL>>5);
 211   2               uint32 EID = (RXBnSIDL & 3) << 16 | (RXBnEID8<<8) | RXBnEID0;
 212   2               RecMsg->ID = SID<<18 | EID;
 213   2           }
 214   1           else
 215   1           {
 216   2               uint32 SID = (RXBnSIDH<<3) | (RXBnSIDL>>5);
 217   2               RecMsg->ID = SID;
 218   2           }
 219   1      
 220   1           for (i = 0; i < RecMsg->DLC; i++) //»ñÈ¡½ÓÊÕµ½µÄÊý¾Ý
 221   1           {
 222   2              RecMsg->DATA[i] = MCP2515_ReadByte(RXB_CTRL_Address + 6 + i);
 223   2           }
 224   1      
 225   1      //     if (RXB_CTRL_Address==RXB0CTRL)
 226   1      //     {
 227   1      //         MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) | 0xFE);//Çå³ýÖÐ¶Ï±êÖ¾Î»(ÖÐ¶Ï±êÖ¾¼Ä´æÆ÷±ØÐ
             -ëÓÉMCUÇåÁã)
 228   1              MCP2515_WriteByte(CANINTF, 0);//Çå³ýÖÐ¶Ï±êÖ¾Î»(ÖÐ¶Ï±êÖ¾¼Ä´æÆ÷±ØÐëÓÉMCUÇåÁã)
 229   1      //     }
 230   1      //     else if (RXB_CTRL_Address==RXB1CTRL)
 231   1      //     {
 232   1      //         MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) | 0xFD);//Çå³ýÖÐ¶Ï±êÖ¾Î»(ÖÐ¶Ï±êÖ¾¼Ä´æÆ÷±ØÐ
             -ëÓÉMCUÇåÁã)
 233   1      //     }
 234   1      }
 235          
 236          
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 5   

 237          
 238          /*******************************************************************************
 239          * º¯ÊýÃû  : main
 240          * ÃèÊö    : Ö÷º¯Êý£¬ÓÃ»§³ÌÐò´Ómainº¯Êý¿ªÊ¼ÔËÐÐ
 241          * ÊäÈë    : ÎÞ
 242          * Êä³ö    : ÎÞ
 243          * ·µ»ØÖµ  : ÎÞ
 244          * ËµÃ÷    : ÎÞ
 245          *******************************************************************************/
 246          void main(void) {
 247   1          uint32 ID = 0x7FE;
 248   1          uint8 EXIDE = 0;
 249   1          uint8 DLC = 8;
 250   1          uint8 i;
 251   1          uint8 Send_data[] = {0x20, 0xF1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
 252   1      
 253   1          MsgStruct SendMsg;
 254   1          MsgStruct RecMsg;
 255   1      
 256   1          UART_init();    //UART1³õÊ¼»¯ÅäÖÃ
 257   1          Exint_Init();            //Íâ²¿ÖÐ¶Ï1³õÊ¼»¯º¯Êý
 258   1          MCP2515_Init(bitrate_100Kbps);
 259   1      
 260   1          SendMsg.IsSend = 0x1;
 261   1      
 262   1          SendMsg.ID = ID;
 263   1          SendMsg.TYPE = 0x2;
 264   1          SendMsg.EXIDE = 0x0;
 265   1          SendMsg.DLC = 8;
 266   1          *SendMsg.DATA = *Send_data;
 267   1      
 268   1      
 269   1      
 270   1          RecMsg.IsSend = 0;
 271   1      //    Send(&SendMsg);
 272   1      
 273   1          for (i = 0; i < 2; i++) //·¢ËÍ×Ö·û´®£¬Ö±µ½Óöµ½0²Å½áÊø
 274   1          {
 275   2              Send(&SendMsg);
 276   2              ShowMsg(&SendMsg);
 277   2              SendMsg.ID = 0x100;
 278   2              SendMsg.TYPE = 0x2;
 279   2              SendMsg.EXIDE = 0x1;
 280   2              SendMsg.DLC = 7;
 281   2      
 282   2              Delay_Nms(3000);
 283   2      
 284   2              if (CAN_RX0IF_Flag == 1)                            //½ÓÊÕ»º³åÆ÷0 ÂúÖÐ¶Ï±êÖ¾Î»
 285   2              {
 286   3                  Receive(RXB0CTRL, &RecMsg);
 287   3                  CAN_RX0IF_Flag = 0;
 288   3                  ShowMsg(&RecMsg);
 289   3                  printf("CAN_RX0IF_Flag = 0\r\n");
 290   3              }
 291   2      
 292   2              if (CAN_RX1IF_Flag == 1)                            //½ÓÊÕ»º³åÆ÷1 ÂúÖÐ¶Ï±êÖ¾Î»
 293   2              {
 294   3                  Receive(RXB1CTRL, &RecMsg);
 295   3                  CAN_RX1IF_Flag = 0;
 296   3                  ShowMsg(&RecMsg);
 297   3                  printf("CAN_RX1IF_Flag = 1\r\n");
 298   3              }
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 02:49:22 PAGE 6   

 299   2          }
 300   1      
 301   1          Delay_Nms(2000);
 302   1      
 303   1          while (1) {
 304   2      
 305   2      //        if (CAN_RX0IF_Flag == 1)                            //½ÓÊÕ»º³åÆ÷0 ÂúÖÐ¶Ï±êÖ¾Î»
 306   2      //        {
 307   2      //            CAN_RX0IF_Flag = 0;//CAN½ÓÊÕµ½Êý¾Ý±êÖ¾
 308   2      //            Receive(RXB0CTRL, RXB_Value);//CAN½ÓÊÕÒ»Ö¡Êý¾Ý
 309   2      //            Delay_Nms(2000);  //ÒÆ¶¯µ½ÏÂÒ»¸ö×Ö·û
 310   2      //
 311   2      //        }
 312   2      //        if (CAN_RX1IF_Flag == 1)                            //½ÓÊÕ»º³åÆ÷1 ÂúÖÐ¶Ï±êÖ¾Î»
 313   2      //        {
 314   2      //            CAN_RX1IF_Flag = 0;//CAN½ÓÊÕµ½Êý¾Ý±êÖ¾
 315   2      //            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN½ÓÊÕÒ»Ö¡Êý¾Ý
 316   2      ////            UART_send_buffer(RXB_Value, 14); //·¢ËÍÒ»¸ö×Ö·û
 317   2      //            Delay_Nms(2000);  //ÒÆ¶¯µ½ÏÂÒ»¸ö×Ö·û
 318   2      ////      UART_send_buffer(RXB_Value,14); //·¢ËÍÒ»¸ö×Ö·û
 319   2      //        }
 320   2      //
 321   2      //        Delay_Nms(2000);
 322   2          }
 323   1      
 324   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1198    ----
   CONSTANT SIZE    =    191    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      91
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
