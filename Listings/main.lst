C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 01:40:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //声明函数
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_Init(uint8 *CAN_Bitrate);
  15          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  16          extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  17          
  18          
  19          bool CAN_MERRF_Flag = 0;                            //CAN报文错误中断标志位
  20          bool CAN_WAKIF_Flag = 0;                            //CAN唤醒中断标志位
  21          bool CAN_ERRIF_Flag = 0;                            //CAN错误中断标志位（EFLG 寄存器中有多个中断源）
  22          bool CAN_TX2IF_Flag = 0;                            //MCP2515发送缓冲器2 空中断标志位
  23          bool CAN_TX1IF_Flag = 0;                            //MCP2515发送缓冲器1 空中断标志位
  24          bool CAN_TX0IF_Flag = 0;                            //MCP2515发送缓冲器0 空中断标志位
  25          bool CAN_RX1IF_Flag = 0;                            //MCP2515接收缓冲器1 满中断标志位
  26          bool CAN_RX0IF_Flag = 0;                            //MCP2515接收缓冲器0 满中断标志位
  27          
  28          
  29          
  30          char putchar(char c)  //printf函数会调用putchar()
  31          {
  32   1          UART_send_str(c);
  33   1          return c;
  34   1      }
  35          
  36          //MCP2515波特率 要考虑FOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
  37          uint8 code bitrate_5Kbps[5]={ CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  38          uint8 code bitrate_10Kbps[5]={ CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  39          uint8 code bitrate_25Kbps[5]={ CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  40          uint8 code bitrate_50Kbps[5]={CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  41          uint8 code bitrate_100Kbps[5]={CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
  42          uint8 code bitrate_125Kbps[5]={CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  43          uint8 code bitrate_250Kbps[5]={CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  44          uint8 code bitrate_500Kbps[5]={CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
  45          
  46          /*******************************************************************************
  47          * 函数名  : Exint_Init
  48          * 描述    : 外部中断1初始化函数
  49          * 输入    : 无
  50          * 输出    : 无
  51          * 返回值  : 无
  52          * 说明    : 无
  53          *******************************************************************************/
  54          void Exint_Init(void) {
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 01:40:24 PAGE 2   

  55   1          PX1 = 1;        //设置外部中断1的中断优先级为高优先级
  56   1          IT1 = 1;    //设置INT1的中断类型 (1:仅下降沿 0:上升沿和下降沿)
  57   1          EX1 = 1;    //使能INT1中断
  58   1          EA = 1;    //使能总中断
  59   1      }
  60          
  61          /*******************************************************************************
  62          * 函数名  : Exint_ISR
  63          * 描述    : 外部中断1中断服务函数 单片机引脚P3.3接MCP2515 INT引脚
  64          * 输入    : 无
  65          * 输出    : 无
  66          * 返回值  : 无
  67          * 说明    : 用于检测MCP2515中断引脚的中断信号
  68          *******************************************************************************/
  69          void Exint_ISR(void) interrupt 2 using 1
  70          {
  71   1          uint8 Flag;                                //CAN接收到数据标志
  72   1          Flag = MCP2515_ReadByte(CANINTF);
  73   1      
  74   1          if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN报文错误中断标志位
  75   1          if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN唤醒中断标志位
  76   1          if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN错误中断标志位（EFLG 寄存器中有多个
             -中断源）
  77   1          if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515发送缓冲器2 空中断标志位
  78   1          if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515发送缓冲器1 空中断标志位
  79   1          if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515发送缓冲器0 空中断标志位
  80   1          if (Flag&0x02) CAN_RX1IF_Flag = 1;                            //MCP2515接收缓冲器1 满中断标志位
  81   1          if (Flag&0x01) CAN_RX0IF_Flag = 1;                           //MCP2515接收缓冲器0 满中断标志位
  82   1      }
  83          
  84          uint8 *NumToStr(uint16 num, uint8 radix) {
  85   1          static char str[8];      //必须为static变量，或者是全局变量
  86   1      
  87   1          uint8 tmp;
  88   1          uint8 i = 0;
  89   1          uint8 j = 0;
  90   1          uint8 NewStr[8] = {0};
  91   1      
  92   1          do      //从各位开始变为字符，直到最高位，最后应该反转
  93   1          {
  94   2              tmp = num % radix;
  95   2              num = num / radix;
  96   2              NewStr[i++] = tmp;
  97   2          } while (num > 0);
  98   1          do      //从各位开始变为字符，直到最高位，最后应该反转
  99   1          {
 100   2              tmp = NewStr[--i];
 101   2              if (tmp <= 9)              // 转换为 0-9 或 A-F
 102   2                  str[j++] = tmp + '0';
 103   2              else
 104   2                  str[j++] = tmp - 10 + 'A';
 105   2          } while (i > 0);
 106   1          str[j] = '\0';                 // 添加字符串结束符
 107   1          return str;
 108   1      }
 109          
 110          uint8 i;
 111          ///* 将需要发送的数据 转发到uart */
 112          //void Send(uint16 ID, uint8 EXIDE, uint8 DLC, uint8 *Send_data) {
 113          //    if (EXIDE)
 114          //    {
 115          //        printf("Can send ID: %08X,  DLC:%bx,  Data: ", ID, DLC);
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 01:40:24 PAGE 3   

 116          //    }
 117          //    else
 118          //    {
 119          //        printf("Can send ID: %8X,  DLC:%bx,  Data: ", ID, DLC);
 120          //    }
 121          //
 122          //    for( i=0;i<DLC;i++ )
 123          //    {
 124          //        printf("%02bX " , Send_data[i]);
 125          //    }
 126          //    printf("\r\n");
 127          //    CAN_Send_buffer(ID, EXIDE, DLC, Send_data);
 128          //}
 129          
 130          void ShowMsg(MsgStruct *Msg)
 131          {
 132   1          uint8 i;
 133   1          uint32 ID = Msg->ID;
 134   1          uint8 EXIDE = Msg->EXIDE;
 135   1          uint8 DLC = Msg->DLC;
 136   1      
 137   1          if (Msg->IsSend)
 138   1          {
 139   2              printf("Can send   ");
 140   2          } else {
 141   2              printf("Can recevie");
 142   2          }
 143   1      
 144   1          if (EXIDE)
 145   1          {
 146   2              printf("Can send ID: %07lX,  DLC:%bx,  Data: ", ID, DLC);
 147   2          }
 148   1          else
 149   1          {
 150   2              printf("Can send ID: %7lX,  DLC:%bx,  Data: ", ID, DLC);
 151   2          }
 152   1      
 153   1          for( i=0;i<DLC;i++ )
 154   1          {
 155   2              printf("%02bX " , Msg->DATA[i]);
 156   2          }
 157   1      
 158   1          printf("\r\n");
 159   1      }
 160          
 161          /* 将需要发送的数据 转发到uart */
 162          void Send(MsgStruct *SendMsg) {
 163   1          uint8 i;
 164   1          uint32 ID = SendMsg->ID;
 165   1          uint8 EXIDE = SendMsg->EXIDE;
 166   1          uint8 DLC = SendMsg->DLC;
 167   1          ShowMsg(SendMsg);
 168   1          CAN_Send_buffer(ID, EXIDE, DLC, SendMsg->DATA);
 169   1      }
*** WARNING C280 IN LINE 163 OF main.c: 'i': unreferenced local variable
 170          
 171          /* 将需要发送的数据 转发到uart, CAN_RX_Buf[14]*/
 172          void Receive(uint8 RXB_CTRL_Address, uint8 *CAN_RX_Buf) {
 173   1          uint8 i;
 174   1          uint8 Receive_DLC = 0;
 175   1          uint8 Read_RXB_CTRL = 0;
 176   1          uint8 Receive_data[8] = {0};
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 01:40:24 PAGE 4   

 177   1      
 178   1          CAN_Receive_Buffer(RXB_CTRL_Address, CAN_RX_Buf);//CAN接收一帧数据
 179   1      
 180   1          Receive_DLC = CAN_RX_Buf[5] & 0x0F; //获取接收到的数据长度
 181   1          printf("Receive RXB_CTRL_Address: %bX, DLC:%bx, Data:", RXB_CTRL_Address, Receive_DLC);
 182   1      
 183   1          for (i = 0; i < Receive_DLC; i++) //获取接收到的数据
 184   1          {
 185   2              Receive_data[i] = CAN_RX_Buf[6 + i];
 186   2              printf("%02bX " , Receive_data[i]);
 187   2          }
 188   1          printf("\r\n");
 189   1      //  获取接收缓存器及验收滤波器， 待优化
 190   1          Read_RXB_CTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 191   1          printf("Read_RXB_CTRL: %02bX,  RXF:%bX \r\n", Read_RXB_CTRL, Read_RXB_CTRL & 0x07);
 192   1      }
 193          
 194          /*******************************************************************************
 195          * 函数名  : main
 196          * 描述    : 主函数，用户程序从main函数开始运行
 197          * 输入    : 无
 198          * 输出    : 无
 199          * 返回值  : 无
 200          * 说明    : 无
 201          *******************************************************************************/
 202          void main(void) {
 203   1          uint16 j;
 204   1          uint32 ID = 0x7FD;
 205   1          uint8 EXIDE = 0;
 206   1          uint8 DLC = 8;
 207   1          uint8 Send_data[] = {0x20, 0xF1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
 208   1      
 209   1          MsgStruct SendMsg;
 210   1          MsgStruct RecMsg;
 211   1      
 212   1          UART_init();    //UART1初始化配置
 213   1          Exint_Init();            //外部中断1初始化函数
 214   1          MCP2515_Init(bitrate_100Kbps);
 215   1      
 216   1          SendMsg.ID = 0x123;
 217   1          SendMsg.TYPE = 0x2;
 218   1          SendMsg.IsSend = 0x1;
 219   1          SendMsg.EXIDE = 0x0;
 220   1          SendMsg.DLC = 8;
 221   1          *SendMsg.DATA = *Send_data;
 222   1          Send(&SendMsg);
 223   1      
 224   1          SendMsg.IsSend = 0;
 225   1          Send(&SendMsg);
 226   1      
 227   1          for (j = 0; j < 2; j++) //发送字符串，直到遇到0才结束
 228   1          {
 229   2      //        Send(ID, EXIDE, DLC, Send_data);
 230   2              ID++;
 231   2              EXIDE = !EXIDE;
 232   2              DLC--;
 233   2              Delay_Nms(1000);
 234   2          }
 235   1      
 236   1          Delay_Nms(2000);
 237   1      
 238   1          while (1) {
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 01:40:24 PAGE 5   

 239   2      
 240   2      //        if (CAN_RX0IF_Flag == 1)                            //接收缓冲器0 满中断标志位
 241   2      //        {
 242   2      //            CAN_RX0IF_Flag = 0;//CAN接收到数据标志
 243   2      //            Receive(RXB0CTRL, RXB_Value);//CAN接收一帧数据
 244   2      //            Delay_Nms(2000);  //移动到下一个字符
 245   2      //
 246   2      //        }
 247   2      //        if (CAN_RX1IF_Flag == 1)                            //接收缓冲器1 满中断标志位
 248   2      //        {
 249   2      //            CAN_RX1IF_Flag = 0;//CAN接收到数据标志
 250   2      //            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN接收一帧数据
 251   2      ////            UART_send_buffer(RXB_Value, 14); //发送一个字符
 252   2      //            Delay_Nms(2000);  //移动到下一个字符
 253   2      ////      UART_send_buffer(RXB_Value,14); //发送一个字符
 254   2      //        }
 255   2      //
 256   2      //        Delay_Nms(2000);
 257   2          }
 258   1      
 259   1      }
*** WARNING C280 IN LINE 210 OF main.c: 'RecMsg': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    921    ----
   CONSTANT SIZE    =    253    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      91
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
