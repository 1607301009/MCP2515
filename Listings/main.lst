C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //声明函数
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_WriteByte(uint8 addr,uint8 dat);
  15          extern void MCP2515_Init(uint8 *CAN_Bitrate);
  16          extern void Can_Init(CanCfgStruct *CanCfg);
  17          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  18          extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  19          
  20          // 存储模块
  21          extern void E2Read(unsigned char *buf, unsigned char addr, unsigned char len);
  22          extern void E2Write(unsigned char *buf, unsigned char addr, unsigned char len);
  23          
  24          bool CAN_MERRF_Flag = 0;                            //CAN报文错误中断标志位
  25          bool CAN_WAKIF_Flag = 0;                            //CAN唤醒中断标志位
  26          bool CAN_ERRIF_Flag = 0;                            //CAN错误中断标志位（EFLG 寄存器中有多个中断源）
  27          bool CAN_TX2IF_Flag = 0;                            //MCP2515发送缓冲器2 空中断标志位
  28          bool CAN_TX1IF_Flag = 0;                            //MCP2515发送缓冲器1 空中断标志位
  29          bool CAN_TX0IF_Flag = 0;                            //MCP2515发送缓冲器0 空中断标志位
  30          bool CAN_RX1IF_Flag = false;                            //MCP2515接收缓冲器1 满中断标志位
  31          bool CAN_RX0IF_Flag = false;                            //MCP2515接收缓冲器0 满中断标志位
  32          
  33          
  34          char putchar(char c)  //printf函数会调用putchar()
  35          {
  36   1          UART_send_str(c);
  37   1          return c;
  38   1      }
  39          
  40          //MCP2515波特率 要考虑FOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
  41          uint8 code bitrate_5Kbps[5] = {CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  42          uint8 code bitrate_10Kbps[5] = {CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  43          uint8 code bitrate_25Kbps[5] = {CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  44          uint8 code bitrate_50Kbps[5] = {CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  45          uint8 code bitrate_100Kbps[5] = {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
  46          uint8 code bitrate_125Kbps[5] = {CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  47          uint8 code bitrate_250Kbps[5] = {CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  48          uint8 code bitrate_500Kbps[5] = {CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
  49          
  50          /*******************************************************************************
  51          * 函数名  : Exint_Init
  52          * 描述    : 外部中断1初始化函数
  53          * 输入    : 无
  54          * 输出    : 无
C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 2   

  55          * 返回值  : 无
  56          * 说明    : 无
  57          *******************************************************************************/
  58          void Exint_Init(void) {
  59   1          PX1 = 1;        //设置外部中断1的中断优先级为高优先级
  60   1          IT1 = 1;    //设置INT1的中断类型 (1:仅下降沿 0:上升沿和下降沿)
  61   1          EX1 = 1;    //使能INT1中断
  62   1          EA = 1;    //使能总中断
  63   1      }
  64          
  65          /*******************************************************************************
  66          * 函数名  : Exint_ISR
  67          * 描述    : 外部中断1中断服务函数 单片机引脚P3.3接MCP2515 INT引脚
  68          * 输入    : 无
  69          * 输出    : 无
  70          * 返回值  : 无
  71          * 说明    : 用于检测MCP2515中断引脚的中断信号
  72          *******************************************************************************/
  73          void Exint_ISR(void) interrupt 2 using 1
  74          {
  75   1          uint8 Flag;                                //CAN接收到数据标志
  76   1          Flag = MCP2515_ReadByte(CANINTF);
  77   1      
  78   1          if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN报文错误中断标志位
  79   1          if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN唤醒中断标志位
  80   1          if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN错误中断标志位（EFLG 寄存器中有多个
             -中断源）
  81   1          if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515发送缓冲器2 空中断标志位
  82   1          if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515发送缓冲器1 空中断标志位
  83   1          if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515发送缓冲器0 空中断标志位
  84   1          if (Flag&0x02) CAN_RX1IF_Flag = true;                            //MCP2515接收缓冲器1 满中断标志位
  85   1          if (Flag&0x01) CAN_RX0IF_Flag = true;                           //MCP2515接收缓冲器0 满中断标志位
  86   1      }
  87          
  88          void ShowMsg(MsgStruct *Msg) {
  89   1          uint8 i;
  90   1          uint32 ID = Msg->ID;
  91   1          uint8 EXIDE = Msg->EXIDE;
  92   1          uint8 DLC = Msg->DLC;
  93   1      
  94   1          if (Msg->IsSend) {
  95   2              printf("Can send    ");
  96   2          } else {
  97   2              printf("Can recevie ");
  98   2          }
  99   1      
 100   1          if (EXIDE) {
 101   2              printf("ID: %07lX,  DLC:%bx,  Data: ", ID, DLC);
 102   2          } else {
 103   2              printf("ID: %7lX,  DLC:%bx,  Data: ", ID, DLC);
 104   2          }
 105   1      
 106   1          for (i = 0; i < DLC; i++) {
 107   2              printf("%02bX ", Msg->DATA[i]);
 108   2          }
 109   1      
 110   1          printf("\r\n");
 111   1      }
 112          
 113          /* 将需要发送的数据 转发到uart */
 114          void Send(MsgStruct *SendMsg) {
 115   1          uint32 ID = SendMsg->ID;
C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 3   

 116   1          uint8 EXIDE = SendMsg->EXIDE;
 117   1          uint8 DLC = SendMsg->DLC;
 118   1          CAN_Send_buffer(ID, EXIDE, DLC, SendMsg->DATA);
 119   1      }
 120          
 121          /* 将需要发送的数据 转发到uart, CAN_RX_Buf[14]*/
 122          void Receive(uint8 RXB_CTRL_Address, MsgStruct *RecMsg) {
 123   1          uint8 i;
 124   1      
 125   1          uint8 RXBnCTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 126   1          uint8 RXBnSIDH = MCP2515_ReadByte(RXB_CTRL_Address + 1);
 127   1          uint8 RXBnSIDL = MCP2515_ReadByte(RXB_CTRL_Address + 2);
 128   1          uint8 RXBnEID8 = MCP2515_ReadByte(RXB_CTRL_Address + 3);
 129   1          uint8 RXBnEID0 = MCP2515_ReadByte(RXB_CTRL_Address + 4);
 130   1          uint8 RXBnDLC = MCP2515_ReadByte(RXB_CTRL_Address + 5);
 131   1      
 132   1          RecMsg->EXIDE = (RXBnSIDL & 0x8) >> 3;  // 扩展标识符标志位 1 = 收到的报文是扩展帧, 0 = 收到的报文是标
             -准帧
 133   1          RecMsg->DLC = RXBnDLC & 0x0F;
 134   1      
 135   1          if (RecMsg->EXIDE) {
 136   2              uint32 SID = (RXBnSIDH << 3) | (RXBnSIDL >> 5);
 137   2              uint32 EID = (RXBnSIDL & 3) << 16 | (RXBnEID8 << 8) | RXBnEID0;
 138   2              RecMsg->ID = SID << 18 | EID;
 139   2          } else {
 140   2              uint32 SID = (RXBnSIDH << 3) | (RXBnSIDL >> 5);
 141   2              RecMsg->ID = SID;
 142   2          }
 143   1      
 144   1          for (i = 0; i < RecMsg->DLC; i++) //获取接收到的数据
 145   1          {
 146   2              RecMsg->DATA[i] = MCP2515_ReadByte(RXB_CTRL_Address + 6 + i);
 147   2          }
 148   1      }
 149          
 150          void SetCfg(CanCfgStruct *CanCfg)
 151          {
 152   1      //     *(CanCfg->bitrate) = &bitrate_100Kbps[0];  // {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ}
 153   1          CanCfg->bitrate[0] = bitrate_100Kbps[0];
 154   1          CanCfg->bitrate[1] = bitrate_100Kbps[1];
 155   1          CanCfg->bitrate[2] = bitrate_100Kbps[2];
 156   1          CanCfg->bitrate[3] = bitrate_100Kbps[3];
 157   1          CanCfg->bitrate[4] = bitrate_100Kbps[4];
 158   1          CanCfg->BUKT_enable = 1;
 159   1          CanCfg->CAN_MODE = 3;       // 000 = 设定为正常工作模式
 160   1                                      // 001 = 设定为休眠模式
 161   1                                      // 010 = 设定为环回模式
 162   1                                      // 011 = 设定为仅监听模式
 163   1                                      // 100 = 设定为配置模式
 164   1          CanCfg->CANINTE_enable = 3;
 165   1          CanCfg->CANINTF_enable = 0;
 166   1      
 167   1          CanCfg->RXM0ID = 0x1FFFFFFF;
 168   1          CanCfg->RXM1ID = 0x1FFFFFFF;
 169   1      
 170   1          CanCfg->RXF0ID = 0x100;
 171   1          CanCfg->RXF1ID = 0x7FE;
 172   1          CanCfg->RXF2ID = 0x101;
 173   1          CanCfg->RXF3ID = 0x102;
 174   1          CanCfg->RXF4ID = 0x103;
 175   1          CanCfg->RXF5ID = 0x104;
 176   1      
C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 4   

 177   1          CanCfg->RXF0IDE = 1;
 178   1          CanCfg->RXF1IDE = 0;
 179   1          CanCfg->RXF2IDE = 0;
 180   1          CanCfg->RXF3IDE = 1;
 181   1          CanCfg->RXF4IDE = 0;
 182   1          CanCfg->RXF5IDE = 1;
 183   1      }
 184          
 185          void ReadCfg(void) {
 186   1          printf("CNF1: %02bX ", MCP2515_ReadByte(CNF1));
 187   1          printf("CNF2: %02bX ", MCP2515_ReadByte(CNF2));
 188   1          printf("CNF3: %02bX \r\n", MCP2515_ReadByte(CNF3));
 189   1          printf("RXB0CTRL: %02bX ", MCP2515_ReadByte(RXB0CTRL));
 190   1          printf("CANINTF: %02bX ", MCP2515_ReadByte(CANINTF));
 191   1          printf("CANINTE: %02bX \r\n", MCP2515_ReadByte(CANINTE));
 192   1          printf("RXF0SIDH: %02bX ", MCP2515_ReadByte(RXF0SIDH));
 193   1          printf("RXF1SIDH: %02bX ", MCP2515_ReadByte(RXF1SIDH));
 194   1          printf("RXF2SIDH: %02bX \r\n", MCP2515_ReadByte(RXF2SIDH));
 195   1          printf("RXF3SIDH: %02bX ", MCP2515_ReadByte(RXF3SIDH));
 196   1          printf("RXF4SIDH: %02bX ", MCP2515_ReadByte(RXF4SIDH));
 197   1          printf("RXF5SIDH: %02bX \r\n", MCP2515_ReadByte(RXF5SIDH));
 198   1          printf("RXM0SIDH: %02bX ", MCP2515_ReadByte(RXM0SIDH));
 199   1          printf("RXM1SIDH: %02bX ", MCP2515_ReadByte(RXM1SIDH));
 200   1          printf("CANCTRL: %02bX \r\n", MCP2515_ReadByte(CANCTRL));
 201   1      }
 202          
 203          /*******************************************************************************
 204          * 函数名  : main
 205          * 描述    : 主函数，用户程序从main函数开始运行
 206          * 输入    : 无
 207          * 输出    : 无
 208          * 返回值  : 无
 209          * 说明    : 无
 210          *******************************************************************************/
 211          void main(void) {
 212   1          uint32 ID = 0x101;
 213   1          uint8 EXIDE = 0;
 214   1          uint8 DLC = 8;
 215   1          uint8 i;
 216   1          uint8 CANINTF_Flag;
 217   1          uint8 Send_data[] = {0x20, 0xF1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
 218   1      
 219   1          MsgStruct SendMsg;
 220   1          MsgStruct RecMsg;
 221   1      
 222   1          CanCfgStruct CanCfg;
 223   1          SetCfg(&CanCfg);
 224   1      
 225   1          UART_init();    //UART1初始化配置
 226   1          Exint_Init();            //外部中断1初始化函数
 227   1      //    MCP2515_Init(bitrate_100Kbps);
 228   1      
 229   1          Can_Init(&CanCfg);
 230   1          E2Write(Send_data, 0x00, sizeof(Send_data));
 231   1          E2Read(Send_data, 0x00, sizeof(Send_data));  // 从 EEPROM 读取一段数据
 232   1      
 233   1      //    ReadCfg();
 234   1      
 235   1          SendMsg.IsSend = 0x1;
 236   1      
 237   1          SendMsg.ID = ID;
 238   1          SendMsg.TYPE = 0x2;
C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 5   

 239   1          SendMsg.EXIDE = 0x0;
 240   1          SendMsg.DLC = 8;
 241   1      
 242   1          for (i = 0; i < 8; i++) //发送字符串，直到遇到0才结束
 243   1          {
 244   2              SendMsg.DATA[i] = Send_data[i];
 245   2      //        printf("SendMsg.DATA[%bd] = %bx \r\n", i, SendMsg.DATA[i]);
 246   2          }
 247   1      
 248   1          RecMsg.IsSend = 0;
 249   1      //    Send(&SendMsg);
 250   1      
 251   1          for (i = 0; i < 2; i++) //发送字符串，直到遇到0才结束
 252   1          {
 253   2              Send(&SendMsg);
 254   2              ShowMsg(&SendMsg);
 255   2              SendMsg.ID = 0x100;
 256   2              SendMsg.TYPE = 0x2;
 257   2              SendMsg.EXIDE = 0x1;
 258   2              SendMsg.DLC = 7;
 259   2      
 260   2              Delay_Nms(3000);
 261   2      
 262   2              printf("CAN_RX0IF_Flag = %bd \r\n", CAN_RX0IF_Flag);
 263   2              printf("CAN_RX1IF_Flag = %bd \r\n", CAN_RX1IF_Flag);
 264   2              printf("CANSTAT: %02bX \r\n", MCP2515_ReadByte(CANSTAT));
 265   2      
 266   2      
 267   2              CANINTF_Flag = MCP2515_ReadByte(CANINTF);
 268   2              printf("CANINTF: %02bX \r\n", CANINTF_Flag);
 269   2      
 270   2              if (CANINTF_Flag & RX0IF) {
 271   3                  Receive(RXB0CTRL, &RecMsg);
 272   3                  ShowMsg(&RecMsg);
 273   3                  MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFE);//清除中断标志位(中断标志寄存器必
             -须由MCU清零)
 274   3              }
 275   2      
 276   2              if (CANINTF_Flag & RX1IF) {
 277   3                  Receive(RXB1CTRL, &RecMsg);
 278   3                  ShowMsg(&RecMsg);
 279   3                  MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFD);//清除中断标志位(中断标志寄存器必
             -须由MCU清零)
 280   3              }
 281   2          }
 282   1      
 283   1          Delay_Nms(2000);
 284   1      
 285   1          while (1) {
 286   2      
 287   2      //        if (CAN_RX0IF_Flag == 1)                            //接收缓冲器0 满中断标志位
 288   2      //        {
 289   2      //            CAN_RX0IF_Flag = 0;//CAN接收到数据标志
 290   2      //            Receive(RXB0CTRL, RXB_Value);//CAN接收一帧数据
 291   2      //            Delay_Nms(2000);  //移动到下一个字符
 292   2      //
 293   2      //        }
 294   2      //        if (CAN_RX1IF_Flag == 1)                            //接收缓冲器1 满中断标志位
 295   2      //        {
 296   2      //            CAN_RX1IF_Flag = 0;//CAN接收到数据标志
 297   2      //            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN接收一帧数据
 298   2      ////            UART_send_buffer(RXB_Value, 14); //发送一个字符
C51 COMPILER V9.60.0.0   MAIN                                                              09/30/2021 03:05:53 PAGE 6   

 299   2      //            Delay_Nms(2000);  //移动到下一个字符
 300   2      ////      UART_send_buffer(RXB_Value,14); //发送一个字符
 301   2      //        }
 302   2      //
 303   2      //        Delay_Nms(2000);
 304   2          }
 305   1      
 306   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1708    ----
   CONSTANT SIZE    =    475    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----     123
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
