C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 00:49:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //声明函数
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_Init(uint8 *CAN_Bitrate);
  15          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  16          extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  17          
  18          
  19          bool CAN_MERRF_Flag = 0;                            //CAN报文错误中断标志位
  20          bool CAN_WAKIF_Flag = 0;                            //CAN唤醒中断标志位
  21          bool CAN_ERRIF_Flag = 0;                            //CAN错误中断标志位（EFLG 寄存器中有多个中断源）
  22          bool CAN_TX2IF_Flag = 0;                            //MCP2515发送缓冲器2 空中断标志位
  23          bool CAN_TX1IF_Flag = 0;                            //MCP2515发送缓冲器1 空中断标志位
  24          bool CAN_TX0IF_Flag = 0;                            //MCP2515发送缓冲器0 空中断标志位
  25          bool CAN_RX1IF_Flag = 0;                            //MCP2515接收缓冲器1 满中断标志位
  26          bool CAN_RX0IF_Flag = 0;                            //MCP2515接收缓冲器0 满中断标志位
  27          
  28          
  29          
  30          char putchar(char c)  //printf函数会调用putchar()
  31          {
  32   1          UART_send_str(c);
  33   1          return c;
  34   1      }
  35          
  36          //MCP2515波特率 要考虑FOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
  37          uint8 code bitrate_5Kbps[5]={ CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  38          uint8 code bitrate_10Kbps[5]={ CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  39          uint8 code bitrate_25Kbps[5]={ CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  40          uint8 code bitrate_50Kbps[5]={CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  41          uint8 code bitrate_100Kbps[5]={CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
  42          uint8 code bitrate_125Kbps[5]={CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  43          uint8 code bitrate_250Kbps[5]={CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  44          uint8 code bitrate_500Kbps[5]={CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
  45          
  46          /*******************************************************************************
  47          * 函数名  : Exint_Init
  48          * 描述    : 外部中断1初始化函数
  49          * 输入    : 无
  50          * 输出    : 无
  51          * 返回值  : 无
  52          * 说明    : 无
  53          *******************************************************************************/
  54          void Exint_Init(void) {
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 00:49:17 PAGE 2   

  55   1          PX1 = 1;        //设置外部中断1的中断优先级为高优先级
  56   1          IT1 = 1;    //设置INT1的中断类型 (1:仅下降沿 0:上升沿和下降沿)
  57   1          EX1 = 1;    //使能INT1中断
  58   1          EA = 1;    //使能总中断
  59   1      }
  60          
  61          /*******************************************************************************
  62          * 函数名  : Exint_ISR
  63          * 描述    : 外部中断1中断服务函数 单片机引脚P3.3接MCP2515 INT引脚
  64          * 输入    : 无
  65          * 输出    : 无
  66          * 返回值  : 无
  67          * 说明    : 用于检测MCP2515中断引脚的中断信号
  68          *******************************************************************************/
  69          void Exint_ISR(void) interrupt 2 using 1
  70          {
  71   1          uint8 Flag;                                //CAN接收到数据标志
  72   1          Flag = MCP2515_ReadByte(CANINTF);
  73   1      
  74   1          if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN报文错误中断标志位
  75   1          if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN唤醒中断标志位
  76   1          if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN错误中断标志位（EFLG 寄存器中有多个
             -中断源）
  77   1          if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515发送缓冲器2 空中断标志位
  78   1          if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515发送缓冲器1 空中断标志位
  79   1          if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515发送缓冲器0 空中断标志位
  80   1          if (Flag&0x02) CAN_RX1IF_Flag = 1;                            //MCP2515接收缓冲器1 满中断标志位
  81   1          if (Flag&0x01) CAN_RX0IF_Flag = 1;                           //MCP2515接收缓冲器0 满中断标志位
  82   1      }
  83          
  84          uint8 *NumToStr(uint16 num, uint8 radix) {
  85   1          static char str[8];      //必须为static变量，或者是全局变量
  86   1      
  87   1          uint8 tmp;
  88   1          uint8 i = 0;
  89   1          uint8 j = 0;
  90   1          uint8 NewStr[8] = {0};
  91   1      
  92   1          do      //从各位开始变为字符，直到最高位，最后应该反转
  93   1          {
  94   2              tmp = num % radix;
  95   2              num = num / radix;
  96   2              NewStr[i++] = tmp;
  97   2          } while (num > 0);
  98   1          do      //从各位开始变为字符，直到最高位，最后应该反转
  99   1          {
 100   2              tmp = NewStr[--i];
 101   2              if (tmp <= 9)              // 转换为 0-9 或 A-F
 102   2                  str[j++] = tmp + '0';
 103   2              else
 104   2                  str[j++] = tmp - 10 + 'A';
 105   2          } while (i > 0);
 106   1          str[j] = '\0';                 // 添加字符串结束符
 107   1          return str;
 108   1      }
 109          
 110          uint8 i;
 111          /* 将需要发送的数据 转发到uart */
 112          void Send(uint16 ID, uint8 EXIDE, uint8 DLC, uint8 *Send_data) {
 113   1          if (EXIDE)
 114   1          {
 115   2              printf("Can send ID: %08X,  DLC:%bx,  Data: ", ID, DLC);
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 00:49:17 PAGE 3   

 116   2          }
 117   1          else
 118   1          {
 119   2              printf("Can send ID: %8X,  DLC:%bx,  Data: ", ID, DLC);
 120   2          }
 121   1      
 122   1          for( i=0;i<DLC;i++ )
 123   1          {
 124   2              printf("%02bX " , Send_data[i]);
 125   2          }
 126   1          printf("\r\n");
 127   1          CAN_Send_buffer(ID, EXIDE, DLC, Send_data);
 128   1      }
 129          
 130          /* 将需要发送的数据 转发到uart, CAN_RX_Buf[14]*/
 131          void Receive(uint8 RXB_CTRL_Address, uint8 *CAN_RX_Buf) {
 132   1          uint8 i;
 133   1          uint8 Receive_DLC = 0;
 134   1          uint8 Read_RXB_CTRL = 0;
 135   1          uint8 Receive_data[8] = {0};
 136   1      
 137   1          CAN_Receive_Buffer(RXB_CTRL_Address, CAN_RX_Buf);//CAN接收一帧数据
 138   1      
 139   1          Receive_DLC = CAN_RX_Buf[5] & 0x0F; //获取接收到的数据长度
 140   1          printf("Receive RXB_CTRL_Address: %bX, DLC:%bx, Data:", RXB_CTRL_Address, Receive_DLC);
 141   1      
 142   1          for (i = 0; i < Receive_DLC; i++) //获取接收到的数据
 143   1          {
 144   2              Receive_data[i] = CAN_RX_Buf[6 + i];
 145   2              printf("%02bX " , Receive_data[i]);
 146   2          }
 147   1          printf("\r\n");
 148   1      //  获取接收缓存器及验收滤波器， 待优化
 149   1          Read_RXB_CTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 150   1          printf("Read_RXB_CTRL: %02bX,  RXF:%bX \r\n", Read_RXB_CTRL, Read_RXB_CTRL & 0x07);
 151   1      }
 152          
 153          /*******************************************************************************
 154          * 函数名  : main
 155          * 描述    : 主函数，用户程序从main函数开始运行
 156          * 输入    : 无
 157          * 输出    : 无
 158          * 返回值  : 无
 159          * 说明    : 无
 160          *******************************************************************************/
 161          void main(void) {
 162   1          uint16 j;
 163   1          uint32 ID = 0x7FD;
 164   1          uint8 EXIDE = 0;
 165   1          uint8 DLC = 8;
 166   1          uint8 Send_data[] = {0x20, 0xF1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
 167   1      
 168   1          UART_init();    //UART1初始化配置
 169   1          Exint_Init();            //外部中断1初始化函数
 170   1      
 171   1          MCP2515_Init(bitrate_100Kbps);
 172   1      
 173   1          for (j = 0; j < 2; j++) //发送字符串，直到遇到0才结束
 174   1          {
 175   2              Send(ID, EXIDE, DLC, Send_data);
 176   2              ID++;
 177   2              EXIDE = !EXIDE;
C51 COMPILER V9.60.0.0   MAIN                                                              09/18/2021 00:49:17 PAGE 4   

 178   2              DLC--;
 179   2              Delay_Nms(1000);
 180   2          }
 181   1      
 182   1          Delay_Nms(2000);
 183   1      
 184   1          while (1) {
 185   2      
 186   2      //        if (CAN_RX0IF_Flag == 1)                            //接收缓冲器0 满中断标志位
 187   2      //        {
 188   2      //            CAN_RX0IF_Flag = 0;//CAN接收到数据标志
 189   2      //            Receive(RXB0CTRL, RXB_Value);//CAN接收一帧数据
 190   2      //            Delay_Nms(2000);  //移动到下一个字符
 191   2      //
 192   2      //        }
 193   2      //        if (CAN_RX1IF_Flag == 1)                            //接收缓冲器1 满中断标志位
 194   2      //        {
 195   2      //            CAN_RX1IF_Flag = 0;//CAN接收到数据标志
 196   2      //            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN接收一帧数据
 197   2      ////            UART_send_buffer(RXB_Value, 14); //发送一个字符
 198   2      //            Delay_Nms(2000);  //移动到下一个字符
 199   2      ////      UART_send_buffer(RXB_Value,14); //发送一个字符
 200   2      //        }
 201   2      //
 202   2      //        Delay_Nms(2000);
 203   2          }
 204   1      
 205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    781    ----
   CONSTANT SIZE    =    227    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      52
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
