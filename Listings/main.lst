C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //声明函数
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_WriteByte(uint8 addr,uint8 dat);
  15          extern void MCP2515_Init(uint8 *CAN_Bitrate);
  16          extern void Can_Init(CanCfgStruct *CanCfg);
  17          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  18          extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  19          
  20          // 存储模块
  21          extern void E2Read(unsigned char *buf, unsigned char addr, unsigned char len);
  22          extern void E2Write(unsigned char *buf, unsigned char addr, unsigned char len);
  23          
  24          //bool CAN_MERRF_Flag = 0;                            //CAN报文错误中断标志位
  25          //bool CAN_WAKIF_Flag = 0;                            //CAN唤醒中断标志位
  26          //bool CAN_ERRIF_Flag = 0;                            //CAN错误中断标志位（EFLG 寄存器中有多个中断源）
  27          //bool CAN_TX2IF_Flag = 0;                            //MCP2515发送缓冲器2 空中断标志位
  28          //bool CAN_TX1IF_Flag = 0;                            //MCP2515发送缓冲器1 空中断标志位
  29          //bool CAN_TX0IF_Flag = 0;                            //MCP2515发送缓冲器0 空中断标志位
  30          bool CAN_RX1IF_Flag = false;                        //MCP2515接收缓冲器1 满中断标志位
  31          bool CAN_RX0IF_Flag = false;                        //MCP2515接收缓冲器0 满中断标志位
  32          
  33          
  34          char putchar(char c)  //printf函数会调用putchar()
  35          {
  36   1          UART_send_str(c);
  37   1          return c;
  38   1      }
  39          
  40          ////MCP2515波特率 要考虑FOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
  41          //uint8 code bitrate_5Kbps[5] = {CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  42          //uint8 code bitrate_10Kbps[5] = {CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  43          //uint8 code bitrate_25Kbps[5] = {CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  44          //uint8 code bitrate_50Kbps[5] = {CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  45          //uint8 code bitrate_100Kbps[5] = {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
  46          //uint8 code bitrate_125Kbps[5] = {CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  47          //uint8 code bitrate_250Kbps[5] = {CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
  48          //uint8 code bitrate_500Kbps[5] = {CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
  49          
  50          
  51          /*******************************************************************************
  52          * 函数名  : Exint_Init
  53          * 描述    : 外部中断1初始化函数
  54          * 输入    : 无
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 2   

  55          * 输出    : 无
  56          * 返回值  : 无
  57          * 说明    : 无
  58          *******************************************************************************/
  59          void Exint_Init(void) {
  60   1          PX1 = 1;        //设置外部中断1的中断优先级为高优先级
  61   1          IT1 = 1;    //设置INT1的中断类型 (1:仅下降沿 0:上升沿和下降沿)
  62   1          EX1 = 1;    //使能INT1中断
  63   1          EA = 1;    //使能总中断
  64   1      }
  65          
  66          /*******************************************************************************
  67          * 函数名  : Exint_ISR
  68          * 描述    : 外部中断1中断服务函数 单片机引脚P3.3接MCP2515 INT引脚
  69          * 输入    : 无
  70          * 输出    : 无
  71          * 返回值  : 无
  72          * 说明    : 用于检测MCP2515中断引脚的中断信号
  73          *******************************************************************************/
  74          void Exint_ISR(void) interrupt 2 using 1
  75          {
  76   1          uint8 Flag;                                //CAN接收到数据标志
  77   1          Flag = MCP2515_ReadByte(CANINTF);
  78   1      
  79   1      //    if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN报文错误中断标志位
  80   1      //    if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN唤醒中断标志位
  81   1      //    if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN错误中断标志位（EFLG 寄存器中有多
             -个中断源）
  82   1      //    if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515发送缓冲器2 空中断标志位
  83   1      //    if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515发送缓冲器1 空中断标志位
  84   1      //    if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515发送缓冲器0 空中断标志位
  85   1          if (Flag&0x02) CAN_RX1IF_Flag = true;                            //MCP2515接收缓冲器1 满中断标志位
  86   1          if (Flag&0x01) CAN_RX0IF_Flag = true;                           //MCP2515接收缓冲器0 满中断标志位
  87   1      }
  88          
  89          void ShowMsg(MsgStruct *Msg) {
  90   1          uint8 i;
  91   1          uint32 ID = Msg->ID;
  92   1          uint8 EXIDE = Msg->EXIDE;
  93   1          uint8 DLC = Msg->DLC;
  94   1      
  95   1          if (Msg->IsSend) {
  96   2              printf("Can send    ");
  97   2          } else {
  98   2              printf("Can recevie ");
  99   2          }
 100   1      
 101   1          if (EXIDE) {
 102   2              printf("ID: %07lX,  DLC:%bx,  Data: ", ID, DLC);
 103   2          } else {
 104   2              printf("ID: %7lX,  DLC:%bx,  Data: ", ID, DLC);
 105   2          }
 106   1      
 107   1          for (i = 0; i < DLC; i++) {
 108   2              printf("%02bX ", Msg->DATA[i]);
 109   2          }
 110   1      
 111   1          printf("\r\n");
 112   1      }
 113          
 114          /* 将需要发送的数据 转发到uart */
 115          void Send(MsgStruct *SendMsg) {
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 3   

 116   1          uint32 ID = SendMsg->ID;
 117   1          uint8 EXIDE = SendMsg->EXIDE;
 118   1          uint8 DLC = SendMsg->DLC;
 119   1          CAN_Send_buffer(ID, EXIDE, DLC, SendMsg->DATA);
 120   1      }
 121          
 122          /* 将需要发送的数据 转发到uart, CAN_RX_Buf[14]*/
 123          void Receive(uint8 RXB_CTRL_Address, MsgStruct *RecMsg) {
 124   1          uint8 i;
 125   1      
 126   1          uint8 RXBnCTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 127   1          uint8 RXBnSIDH = MCP2515_ReadByte(RXB_CTRL_Address + 1);
 128   1          uint8 RXBnSIDL = MCP2515_ReadByte(RXB_CTRL_Address + 2);
 129   1          uint8 RXBnEID8 = MCP2515_ReadByte(RXB_CTRL_Address + 3);
 130   1          uint8 RXBnEID0 = MCP2515_ReadByte(RXB_CTRL_Address + 4);
 131   1          uint8 RXBnDLC = MCP2515_ReadByte(RXB_CTRL_Address + 5);
 132   1      
 133   1          RecMsg->EXIDE = (RXBnSIDL & 0x8) >> 3;  // 扩展标识符标志位 1 = 收到的报文是扩展帧, 0 = 收到的报文是标
             -准帧
 134   1          RecMsg->DLC = RXBnDLC & 0x0F;
 135   1      
 136   1          if (RecMsg->EXIDE) {
 137   2              uint32 SID = (RXBnSIDH << 3) | (RXBnSIDL >> 5);
 138   2              uint32 EID = (RXBnSIDL & 3) << 16 | (RXBnEID8 << 8) | RXBnEID0;
 139   2              RecMsg->ID = SID << 18 | EID;
 140   2          } else {
 141   2              uint32 SID = (RXBnSIDH << 3) | (RXBnSIDL >> 5);
 142   2              RecMsg->ID = SID;
 143   2          }
 144   1      
 145   1          for (i = 0; i < RecMsg->DLC; i++) //获取接收到的数据
 146   1          {
 147   2              RecMsg->DATA[i] = MCP2515_ReadByte(RXB_CTRL_Address + 6 + i);
 148   2          }
 149   1      }
 150          
 151          // 设置比特率
 152          void SetBitrate(uint8 _5Kbps, uint8 *bitrate){
 153   1          uint8 kbps, prseg, phseg1, phseg2, sjw;
 154   1          //MCP2515波特率 要考虑FOSC=8M BRP=0..64 PRSEG=1..8 PHSEG1=3..16 PHSEG2=2..8 SJW=1..4
 155   1          //    uint8 bitrate_5Kbps[5] = {CAN_5Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 156   1          //    uint8 bitrate_10Kbps[5] = {CAN_10Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 157   1          //    uint8 bitrate_25Kbps[5] = {CAN_25Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 158   1          //    uint8 bitrate_50Kbps[5] = {CAN_50Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 159   1          //    uint8 bitrate_100Kbps[5] = {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ};
 160   1          //    uint8 bitrate_125Kbps[5] = {CAN_125Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 161   1          //    uint8 bitrate_250Kbps[5] = {CAN_250Kbps,PRSEG_6TQ,PHSEG1_7TQ,PHSEG2_2TQ,SJW_1TQ};
 162   1          //    uint8 bitrate_500Kbps[5] = {CAN_500Kbps,PRSEG_2TQ,PHSEG1_3TQ,PHSEG2_2TQ,SJW_1TQ};
 163   1          switch (_5Kbps * 5) {
 164   2              case 5:
 165   2                  kbps = CAN_5Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 166   2                  break; /* 可选的 */
 167   2              case 10:
 168   2                  kbps = CAN_10Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 169   2                  break; /* 可选的 */
 170   2              case 25:
 171   2                  kbps = CAN_25Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 172   2                  break; /* 可选的 */
 173   2              case 50:
 174   2                  kbps = CAN_50Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ;
 175   2                  break; /* 可选的 */
 176   2              case 100:
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 4   

 177   2                  kbps = CAN_100Kbps, prseg = PRSEG_8TQ, phseg1 = PHSEG1_8TQ, phseg2 = PHSEG2_3TQ, sjw = SJW_1TQ
             -;
 178   2                  break; /* 可选的 */
 179   2              case 125:
 180   2                  kbps = CAN_125Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
             -;
 181   2                  break; /* 可选的 */
 182   2              case 250:
 183   2                  kbps = CAN_250Kbps, prseg = PRSEG_6TQ, phseg1 = PHSEG1_7TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
             -;
 184   2                  break; /* 可选的 */
 185   2      
 186   2              default : /* 可选的 */
 187   2                  kbps = CAN_500Kbps, prseg = PRSEG_2TQ, phseg1 = PHSEG1_3TQ, phseg2 = PHSEG2_2TQ, sjw = SJW_1TQ
             -;
 188   2          }
 189   1          bitrate[0] = kbps, bitrate[1] = prseg, bitrate[2] = phseg1, bitrate[3] = phseg2, bitrate[4] = sjw;
 190   1      }
 191          
 192          void printE2Write(uint8 *E2_data, uint8 add, uint8 Len) {
 193   1          uint8 i;
 194   1          printf("add: %02bX Len: %02bX Data:", add, Len);
 195   1          for (i = 0; i < Len; i++) //发送字符串，直到遇到0才结束
 196   1          {
 197   2              printf(" %02bX", E2_data[i]);
 198   2          }
 199   1          printf("\r\n");
 200   1      }
 201          
 202          
 203          void SaveCfgToE2(CanCfgStruct *CanCfg) {
 204   1          uint8 E2_data[8];
 205   1      //    uint8 read_data[8];
 206   1      
 207   1          E2_data[E2_5Kbps] = CanCfg->_5Kbps;
 208   1          E2_data[E2_BUKT_enable] = CanCfg->BUKT_enable;
 209   1          E2_data[E2_RXB0RXM] = CanCfg->RXB0RXM;
 210   1          E2_data[E2_RXB1RXM] = CanCfg->RXB1RXM;
 211   1          E2_data[E2_CAN_MODE] = CanCfg->CAN_MODE;
 212   1          E2_data[E2_CANINTE_enable] = CanCfg->CANINTE_enable;
 213   1          E2_data[E2_CANINTF_enable] = CanCfg->CANINTF_enable;
 214   1          E2Write(E2_data, E2_CanCifg, 7);
 215   1      //    printE2Write(E2_data, E2_CanCifg, 7);
 216   1      
 217   1          //    设置屏蔽器0
 218   1          E2_data[0] = CanCfg->RXM0ID >> 24;
 219   1          E2_data[1] = (CanCfg->RXM0ID >> 16) & 0xFF;
 220   1          E2_data[2] = (CanCfg->RXM0ID >> 8) & 0xFF;
 221   1          E2_data[3] = CanCfg->RXM0ID & 0xFF;
 222   1          //    设置屏蔽器1
 223   1          E2_data[4] = CanCfg->RXM0ID >> 24;
 224   1          E2_data[5] = (CanCfg->RXM0ID >> 16) & 0xFF;
 225   1          E2_data[6] = (CanCfg->RXM0ID >> 8) & 0xFF;
 226   1          E2_data[7] = CanCfg->RXM0ID & 0xFF;
 227   1          E2Write(E2_data, E2_RXM01ID, 8);
 228   1      //    printE2Write(E2_data, E2_RXM01ID, 8);
 229   1      
 230   1          // 滤波器0、1， 首位为扩展帧标志位
 231   1          E2_data[0] = CanCfg->RXF0ID >> 24 | (CanCfg->RXF0IDE << 7);
 232   1          E2_data[1] = (CanCfg->RXF0ID >> 16) & 0xFF;
 233   1          E2_data[2] = (CanCfg->RXF0ID >> 8) & 0xFF;
 234   1          E2_data[3] = CanCfg->RXF0ID & 0xFF;
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 5   

 235   1          E2_data[4] = (CanCfg->RXF1ID >> 24) | (CanCfg->RXF1IDE << 7);
 236   1          E2_data[5] = (CanCfg->RXF1ID >> 16) & 0xFF;
 237   1          E2_data[6] = (CanCfg->RXF1ID >> 8) & 0xFF;
 238   1          E2_data[7] = CanCfg->RXF1ID & 0xFF;
 239   1          E2Write(E2_data, E2_RXF01, 8);
 240   1      //    printE2Write(E2_data, E2_RXF01, 8);
 241   1      
 242   1          // 滤波器2、3
 243   1          E2_data[0] = CanCfg->RXF2ID >> 24 | (CanCfg->RXF2IDE << 7);
 244   1          E2_data[1] = (CanCfg->RXF2ID >> 16) & 0xFF;
 245   1          E2_data[2] = (CanCfg->RXF2ID >> 8) & 0xFF;
 246   1          E2_data[3] = CanCfg->RXF2ID & 0xFF;
 247   1          E2_data[4] = (CanCfg->RXF3ID >> 24) | (CanCfg->RXF3IDE << 7);
 248   1          E2_data[5] = (CanCfg->RXF3ID >> 16) & 0xFF;
 249   1          E2_data[6] = (CanCfg->RXF3ID >> 8) & 0xFF;
 250   1          E2_data[7] = CanCfg->RXF3ID & 0xFF;
 251   1          E2Write(E2_data, E2_RXF23, 8);
 252   1      //    printE2Write(E2_data, E2_RXF23, 8);
 253   1      
 254   1          // 滤波器4、5
 255   1          E2_data[0] = CanCfg->RXF4ID >> 24 | (CanCfg->RXF4IDE << 7);
 256   1          E2_data[1] = (CanCfg->RXF4ID >> 16) & 0xFF;
 257   1          E2_data[2] = (CanCfg->RXF4ID >> 8) & 0xFF;
 258   1          E2_data[3] = CanCfg->RXF4ID & 0xFF;
 259   1          E2_data[4] = (CanCfg->RXF5ID >> 24) | (CanCfg->RXF5IDE << 7);
 260   1          E2_data[5] = (CanCfg->RXF5ID >> 16) & 0xFF;
 261   1          E2_data[6] = (CanCfg->RXF5ID >> 8) & 0xFF;
 262   1          E2_data[7] = CanCfg->RXF5ID & 0xFF;
 263   1          E2Write(E2_data, E2_RXF45, 8);
 264   1      //    printE2Write(E2_data, E2_RXF45, 8);
 265   1      }
 266          //
 267          //void PrintfCfg(CanCfgStruct *CanCfg) {
 268          //    printf("_5Kbps: %02bX \r\n", CanCfg->_5Kbps);
 269          //    printf("bitrate[0]: %02bX \r\n", CanCfg->bitrate[0]);
 270          //    printf("bitrate[1]: %02bX \r\n", CanCfg->bitrate[1]);
 271          //    printf("bitrate[2]: %02bX \r\n", CanCfg->bitrate[2]);
 272          //    printf("bitrate[3]: %02bX \r\n", CanCfg->bitrate[3]);
 273          //    printf("bitrate[4]: %02bX \r\n", CanCfg->bitrate[4]);
 274          //    printf("BUKT_enable: %02bX \r\n", CanCfg->BUKT_enable);
 275          //    printf("CAN_MODE: %02bX \r\n", CanCfg->CAN_MODE);
 276          //
 277          //    printf("CANINTE: %02bX \r\n", CanCfg->CANINTE_enable);
 278          //    printf("CANINTF: %02bX \r\n", CanCfg->CANINTF_enable);
 279          //
 280          //    printf("RXM0ID: %08lX \r\n", CanCfg->RXM0ID);
 281          //    printf("RXM1ID: %08lX \r\n", CanCfg->RXM1ID);
 282          //    printf("RXF0ID: %07lX \r\n", CanCfg->RXF0ID);
 283          //    printf("RXF1ID: %07lX \r\n", CanCfg->RXF1ID);
 284          //    printf("RXF2ID: %07lX \r\n", CanCfg->RXF2ID);
 285          //    printf("RXF3ID: %07lX \r\n", CanCfg->RXF3ID);
 286          //    printf("RXF4ID: %07lX \r\n", CanCfg->RXF4ID);
 287          //    printf("RXF5ID: %07lX \r\n", CanCfg->RXF5ID);
 288          //
 289          //    printf("RXF0IDE: %bX \r\n", CanCfg->RXF0IDE);
 290          //    printf("RXF1IDE: %bX \r\n", CanCfg->RXF1IDE);
 291          //    printf("RXF2IDE: %bX \r\n", CanCfg->RXF2IDE);
 292          //    printf("RXF3IDE: %bX \r\n", CanCfg->RXF3IDE);
 293          //    printf("RXF4IDE: %bX \r\n", CanCfg->RXF4IDE);
 294          //    printf("RXF5IDE: %bX \r\n", CanCfg->RXF5IDE);
 295          //}
 296          
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 6   

 297          uint32 GetInt32FormE2(uint8 *buf, uint8 addr) {
 298   1          return (uint32) (((uint32) buf[0 + addr] & 0x7F << 24) | ((uint32) buf[1 + addr] << 16) | ((uint32) bu
             -f[2 + addr] << 8) |
 299   1                           (uint32) buf[3 + addr]);
 300   1      }
 301          
 302          void SetCfgFromE2(CanCfgStruct *CanCfg) {
 303   1          uint8 i;
 304   1          uint8 E2_read_data[8];
 305   1      
 306   1          //  设置波特率
 307   1          E2Read(E2_read_data, E2_CanCifg, sizeof(E2_read_data));  // 从 EEPROM 读取一段数据
 308   1          CanCfg->_5Kbps = E2_read_data[E2_5Kbps];
 309   1          SetBitrate(CanCfg->_5Kbps, &(CanCfg->bitrate));
 310   1          //  设置滚存使能位、工作模式、中断使能位、中断标志位
 311   1          CanCfg->BUKT_enable = E2_read_data[E2_BUKT_enable];
 312   1          CanCfg->CAN_MODE = E2_read_data[E2_CAN_MODE];      // 0:正常 1:休眠 2:环回 3:监听 4:配置
 313   1          CanCfg->CANINTE_enable = E2_read_data[E2_CANINTE_enable];
 314   1          CanCfg->CANINTF_enable = E2_read_data[E2_CANINTF_enable];
 315   1      
 316   1          //  设置屏蔽器
 317   1          E2Read(E2_read_data, E2_RXM01ID, sizeof(E2_read_data));  // 从 EEPROM 读取一段数据
 318   1          CanCfg->RXM0ID = GetInt32FormE2(E2_read_data, 0);
 319   1          CanCfg->RXM1ID = GetInt32FormE2(E2_read_data, 4);
 320   1          //  滤波器0、1
 321   1          E2Read(E2_read_data, E2_RXF01, sizeof(E2_read_data));  // 从 EEPROM 读取一段数据
 322   1          CanCfg->RXF0IDE = E2_read_data[0] >> 7;
 323   1          CanCfg->RXF0ID = GetInt32FormE2(E2_read_data, 0);
 324   1          CanCfg->RXF1IDE = E2_read_data[4] >> 7;
 325   1          CanCfg->RXF1ID = GetInt32FormE2(E2_read_data, 4);
 326   1          //  滤波器0、3
 327   1          E2Read(E2_read_data, E2_RXF23, sizeof(E2_read_data));  // 从 EEPROM 读取一段数据
 328   1          CanCfg->RXF2IDE = E2_read_data[0] >> 7;
 329   1          CanCfg->RXF2ID = GetInt32FormE2(E2_read_data, 0);
 330   1          CanCfg->RXF3IDE = E2_read_data[4] >> 7;
 331   1          CanCfg->RXF3ID = GetInt32FormE2(E2_read_data, 4);
 332   1          //  滤波器0、5
 333   1          E2Read(E2_read_data, E2_RXF45, sizeof(E2_read_data));  // 从 EEPROM 读取一段数据
 334   1          CanCfg->RXF4IDE = E2_read_data[0] >> 7;
 335   1          CanCfg->RXF4ID = GetInt32FormE2(E2_read_data, 0);
 336   1          CanCfg->RXF5IDE = E2_read_data[4] >> 7;
 337   1          CanCfg->RXF5ID = GetInt32FormE2(E2_read_data, 4);
 338   1      }
*** WARNING C280 IN LINE 303 OF main.c: 'i': unreferenced local variable
 339          
 340          void SetCfg(CanCfgStruct *CanCfg)
 341          {
 342   1          CanCfg->_5Kbps = 20;
 343   1      //    {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ}
 344   1          CanCfg->bitrate[0] = CAN_100Kbps;
 345   1          CanCfg->bitrate[1] = PRSEG_8TQ;
 346   1          CanCfg->bitrate[2] = PHSEG1_8TQ;
 347   1          CanCfg->bitrate[3] = PHSEG2_3TQ;
 348   1          CanCfg->bitrate[4] = SJW_1TQ;
 349   1      //    CanCfg->bitrate[0] = bitrate_100Kbps[0];
 350   1      //    CanCfg->bitrate[1] = bitrate_100Kbps[1];
 351   1      //    CanCfg->bitrate[2] = bitrate_100Kbps[2];
 352   1      //    CanCfg->bitrate[3] = bitrate_100Kbps[3];
 353   1      //    CanCfg->bitrate[4] = bitrate_100Kbps[4];
 354   1          CanCfg->BUKT_enable = 1;
 355   1          CanCfg->CAN_MODE = 3;       // 000 = 设定为正常工作模式
 356   1                                      // 001 = 设定为休眠模式
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 7   

 357   1                                      // 010 = 设定为环回模式
 358   1                                      // 011 = 设定为仅监听模式
 359   1                                      // 100 = 设定为配置模式
 360   1          CanCfg->CANINTE_enable = 3;
 361   1          CanCfg->CANINTF_enable = 0;
 362   1      
 363   1          CanCfg->RXM0ID = 0x1FFFFFFF;
 364   1          CanCfg->RXM1ID = 0x1FFFFFFF;
 365   1      
 366   1          CanCfg->RXF0ID = 0x100;
 367   1          CanCfg->RXF1ID = 0x7FE;
 368   1          CanCfg->RXF2ID = 0x101;
 369   1          CanCfg->RXF3ID = 0x102;
 370   1          CanCfg->RXF4ID = 0x103;
 371   1          CanCfg->RXF5ID = 0x104;
 372   1      
 373   1          CanCfg->RXF0IDE = 1;
 374   1          CanCfg->RXF1IDE = 0;
 375   1          CanCfg->RXF2IDE = 0;
 376   1          CanCfg->RXF3IDE = 1;
 377   1          CanCfg->RXF4IDE = 0;
 378   1          CanCfg->RXF5IDE = 1;
 379   1      }
 380          
 381          //void ReadCfg(void) {
 382          //    printf("CNF1: %02bX ", MCP2515_ReadByte(CNF1));
 383          //    printf("CNF2: %02bX ", MCP2515_ReadByte(CNF2));
 384          //    printf("CNF3: %02bX \r\n", MCP2515_ReadByte(CNF3));
 385          //    printf("RXB0CTRL: %02bX ", MCP2515_ReadByte(RXB0CTRL));
 386          //    printf("CANINTF: %02bX ", MCP2515_ReadByte(CANINTF));
 387          //    printf("CANINTE: %02bX \r\n", MCP2515_ReadByte(CANINTE));
 388          //    printf("RXF0SIDH: %02bX ", MCP2515_ReadByte(RXF0SIDH));
 389          //    printf("RXF1SIDH: %02bX ", MCP2515_ReadByte(RXF1SIDH));
 390          //    printf("RXF2SIDH: %02bX \r\n", MCP2515_ReadByte(RXF2SIDH));
 391          //    printf("RXF3SIDH: %02bX ", MCP2515_ReadByte(RXF3SIDH));
 392          //    printf("RXF4SIDH: %02bX ", MCP2515_ReadByte(RXF4SIDH));
 393          //    printf("RXF5SIDH: %02bX \r\n", MCP2515_ReadByte(RXF5SIDH));
 394          //    printf("RXM0SIDH: %02bX ", MCP2515_ReadByte(RXM0SIDH));
 395          //    printf("RXM1SIDH: %02bX ", MCP2515_ReadByte(RXM1SIDH));
 396          //    printf("CANCTRL: %02bX \r\n", MCP2515_ReadByte(CANCTRL));
 397          //}
 398          
 399          /*******************************************************************************
 400          * 函数名  : main
 401          * 描述    : 主函数，用户程序从main函数开始运行
 402          * 输入    : 无
 403          * 输出    : 无
 404          * 返回值  : 无
 405          * 说明    : 无
 406          *******************************************************************************/
 407          void main(void) {
 408   1          uint32 ID = 0x101;
 409   1          uint8 EXIDE = 0;
 410   1          uint8 DLC = 8;
 411   1          uint8 i;
 412   1          uint8 CANINTF_Flag;
 413   1          uint8 Send_data[] = {0x20, 0xF1, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07};
 414   1          uint8 E2_data[8];
 415   1      
 416   1          MsgStruct SendMsg;
 417   1          MsgStruct RecMsg;
 418   1      
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 8   

 419   1          CanCfgStruct CanCfg;
 420   1      
 421   1          UART_init();    //UART1初始化配置
 422   1          Exint_Init();            //外部中断1初始化函数
 423   1      //    MCP2515_Init(bitrate_100Kbps);
 424   1      
 425   1          SetCfg(&CanCfg);
 426   1      //    PrintfCfg(&CanCfg);
 427   1      
 428   1          SaveCfgToE2(&CanCfg);
 429   1      
 430   1          SetCfgFromE2(&CanCfg);
 431   1      //    PrintfCfg(&CanCfg);
 432   1      
 433   1          Can_Init(&CanCfg);
 434   1      
 435   1      //
 436   1      //    E2Write(Send_data, 0xF0, sizeof(Send_data));
 437   1      //    printf("Main Set");
 438   1      //    printE2Write(Send_data, 0xF0, sizeof(Send_data));
 439   1      //    E2Read(E2_data, E2_RXM01ID, sizeof(E2_data));  // 从 EEPROM 读取一段数据
 440   1      //    printf("Main Read ");
 441   1      //    printE2Write(E2_data, E2_RXM01ID, sizeof(E2_data));
 442   1      //    for (i = 0; i < 8; i++) //发送字符串，直到遇到0才结束
 443   1      //        {
 444   1      //        printf("读取数据 : E2_data[%bd] = %bx \r\n", i, E2_data[i]);
 445   1      //        }
 446   1      //    ReadCfg();
 447   1      
 448   1          SendMsg.IsSend = 0x1;
 449   1      
 450   1          SendMsg.ID = ID;
 451   1          SendMsg.TYPE = 0x2;
 452   1          SendMsg.EXIDE = 0x0;
 453   1          SendMsg.DLC = 8;
 454   1      
 455   1          for (i = 0; i < 8; i++) //发送字符串，直到遇到0才结束
 456   1          {
 457   2              SendMsg.DATA[i] = Send_data[i];
 458   2      //        printf("SendMsg.DATA[%bd] = %bx \r\n", i, SendMsg.DATA[i]);
 459   2          }
 460   1      
 461   1          RecMsg.IsSend = 0;
 462   1      //    Send(&SendMsg);
 463   1      
 464   1          for (i = 0; i < 2; i++) //发送字符串，直到遇到0才结束
 465   1          {
 466   2              Send(&SendMsg);
 467   2              ShowMsg(&SendMsg);
 468   2              SendMsg.ID = 0x100;
 469   2              SendMsg.TYPE = 0x2;
 470   2              SendMsg.EXIDE = 0x1;
 471   2              SendMsg.DLC = 7;
 472   2      
 473   2              Delay_Nms(3000);
 474   2      
 475   2              printf("CAN_RX0IF_Flag = %bd \r\n", CAN_RX0IF_Flag);
 476   2              printf("CAN_RX1IF_Flag = %bd \r\n", CAN_RX1IF_Flag);
 477   2              printf("CANSTAT: %02bX \r\n", MCP2515_ReadByte(CANSTAT));
 478   2      
 479   2      
 480   2              CANINTF_Flag = MCP2515_ReadByte(CANINTF);
C51 COMPILER V9.60.0.0   MAIN                                                              10/28/2021 00:33:29 PAGE 9   

 481   2              printf("CANINTF: %02bX \r\n", CANINTF_Flag);
 482   2      
 483   2              if (CANINTF_Flag & RX0IF) {
 484   3                  Receive(RXB0CTRL, &RecMsg);
 485   3                  ShowMsg(&RecMsg);
 486   3                  MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFE);//清除中断标志位(中断标志寄存器必
             -须由MCU清零)
 487   3              }
 488   2      
 489   2              if (CANINTF_Flag & RX1IF) {
 490   3                  Receive(RXB1CTRL, &RecMsg);
 491   3                  ShowMsg(&RecMsg);
 492   3                  MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFD);//清除中断标志位(中断标志寄存器必
             -须由MCU清零)
 493   3              }
 494   2          }
 495   1      
 496   1          Delay_Nms(2000);
 497   1      
 498   1          while (1) {
 499   2      
 500   2      //        if (CAN_RX0IF_Flag == 1)                            //接收缓冲器0 满中断标志位
 501   2      //        {
 502   2      //            CAN_RX0IF_Flag = 0;//CAN接收到数据标志
 503   2      //            Receive(RXB0CTRL, RXB_Value);//CAN接收一帧数据
 504   2      //            Delay_Nms(2000);  //移动到下一个字符
 505   2      //
 506   2      //        }
 507   2      //        if (CAN_RX1IF_Flag == 1)                            //接收缓冲器1 满中断标志位
 508   2      //        {
 509   2      //            CAN_RX1IF_Flag = 0;//CAN接收到数据标志
 510   2      //            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN接收一帧数据
 511   2      ////            UART_send_buffer(RXB_Value, 14); //发送一个字符
 512   2      //            Delay_Nms(2000);  //移动到下一个字符
 513   2      ////      UART_send_buffer(RXB_Value,14); //发送一个字符
 514   2      //        }
 515   2      //
 516   2      //        Delay_Nms(2000);
 517   2          }
 518   1      
 519   1      }
*** WARNING C280 IN LINE 414 OF main.c: 'E2_data': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3621    ----
   CONSTANT SIZE    =    220    ----
   XDATA SIZE       =   ----     173
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
