C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include "MCP2515.H"
   3          #include <stdio.h>
   4          
   5          
   6          //声明函数
   7          extern void UART_init(void);
   8          extern void UART_send_str(uint8 d);
   9          //extern void UART_send_buffer(uint8 *buffer,uint16 len);
  10          
  11          extern void Delay_Nms(uint16 x);
  12          
  13          extern uint8 MCP2515_ReadByte(uint8 addr);
  14          extern void MCP2515_WriteByte(uint8 addr,uint8 dat);
  15          //extern void MCP2515_Init(uint8 *CAN_Bitrate);
  16          extern void Can_Init(CanCfgStruct *CanCfg);
  17          extern void CAN_Send_buffer(uint32 ID,uint8 EXIDE,uint8 DLC,uint8 *Send_data);
  18          //extern void CAN_Receive_Buffer(uint8 RXB_CTRL_Address,uint8 *CAN_RX_Buf);
  19          
  20          // ID转化模块
  21          extern uint32 Get_ID_For_Array(uint8 *array, uint8 offset);
  22          extern void Set_Array_For_ID(uint8 *array, uint8 offset, uint32 ID, uint8 EXIDE);
  23          extern uint32 Get_ID_For_Buf(uint8 buf_addr);
  24          extern void Set_Buf_For_ID(uint8 buf_addr, uint32 ID, uint8 EXIDE);
  25          
  26          extern void Set_Bitrate_Array(uint8 _5Kbps, uint8 *bitrate);
  27          
  28          // 存储模块
  29          extern void E2Read(unsigned char *buf, unsigned char addr, unsigned char len);
  30          extern void E2Write(unsigned char *buf, unsigned char addr, unsigned char len);
  31          
  32          //bool CAN_MERRF_Flag = 0;                            //CAN报文错误中断标志位
  33          //bool CAN_WAKIF_Flag = 0;                            //CAN唤醒中断标志位
  34          //bool CAN_ERRIF_Flag = 0;                            //CAN错误中断标志位（EFLG 寄存器中有多个中断源）
  35          //bool CAN_TX2IF_Flag = 0;                            //MCP2515发送缓冲器2 空中断标志位
  36          //bool CAN_TX1IF_Flag = 0;                            //MCP2515发送缓冲器1 空中断标志位
  37          //bool CAN_TX0IF_Flag = 0;                            //MCP2515发送缓冲器0 空中断标志位
  38          bool CAN_RX1IF_Flag = false;                        //MCP2515接收缓冲器1 满中断标志位
  39          bool CAN_RX0IF_Flag = false;                        //MCP2515接收缓冲器0 满中断标志位
  40          
  41          uint8 main_status = 1;
  42          
  43          /*******************************************************************************
  44          * 描述    : 重定向putchar, 将printf函数打印到串口中。
  45          *******************************************************************************/
  46          char putchar(char c)
  47          {
  48   1          UART_send_str(c);
  49   1          return c;
  50   1      }
  51          
  52          /*******************************************************************************
  53          * 函数名  : Exint_Init
  54          * 描述    : 外部中断1初始化函数
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 2   

  55          *******************************************************************************/
  56          void Exint_Init(void) {
  57   1          PX1 = 1;    //设置外部中断1的中断优先级为高优先级
  58   1          IT1 = 1;    //设置INT1的中断类型 (1:仅下降沿 0:上升沿和下降沿)
  59   1          EX1 = 1;    //使能INT1中断
  60   1          EA = 1;     //使能总中断
  61   1      }
  62          
  63          /*******************************************************************************
  64          * 函数名  : Exint_ISR
  65          * 描述    : 外部中断1中断服务函数 单片机引脚P3.3接MCP2515 INT引脚
  66          * 说明    : 用于检测MCP2515中断引脚的中断信号
  67          *******************************************************************************/
  68          void Exint_ISR(void) interrupt 2 using 1
  69          {
  70   1          uint8 Flag;                                //CAN接收到数据标志
  71   1          Flag = MCP2515_ReadByte(CANINTF);
  72   1      
  73   1      //    if (Flag&0x80) CAN_MERRF_Flag = 1;                            //CAN报文错误中断标志位
  74   1      //    if (Flag&0x40) CAN_WAKIF_Flag = 1;                            //CAN唤醒中断标志位
  75   1      //    if (Flag&0x20) CAN_ERRIF_Flag = 1;                            //CAN错误中断标志位（EFLG 寄存器中有多
             -个中断源）
  76   1      //    if (Flag&0x10) CAN_TX2IF_Flag = 1;                            //MCP2515发送缓冲器2 空中断标志位
  77   1      //    if (Flag&0x08) CAN_TX1IF_Flag = 1;                            //MCP2515发送缓冲器1 空中断标志位
  78   1      //    if (Flag&0x04) CAN_TX0IF_Flag = 1;                            //MCP2515发送缓冲器0 空中断标志位
  79   1          if (Flag&0x02) CAN_RX1IF_Flag = true;                            //MCP2515接收缓冲器1 满中断标志位
  80   1          if (Flag&0x01) CAN_RX0IF_Flag = true;                           //MCP2515接收缓冲器0 满中断标志位
  81   1      }
  82          
  83          /*******************************************************************************
  84          * 描述    : 将msg打印出来
  85          * 输入    : Msg结构体
  86          *******************************************************************************/
  87          //void Printf_Msg(MsgStruct *Msg) {
  88          //    uint8 i;
  89          //    uint32 ID = Msg->ID;
  90          //    uint8 EXIDE = Msg->EXIDE;
  91          //    uint8 DLC = Msg->DLC;
  92          //
  93          //    if (Msg->IsSend) {
  94          //        printf("send ");
  95          //    } else {
  96          //        printf("rec  ");
  97          //    }
  98          //
  99          //    if (EXIDE) {
 100          //        printf("ID: %07lX,  DLC:%bx,  Data: ", ID, DLC);
 101          //    } else {
 102          //        printf("ID: %7lX,  DLC:%bx,  Data: ", ID, DLC);
 103          //    }
 104          //
 105          //    for (i = 0; i < DLC; i++) {
 106          //        printf("%02bX ", Msg->DATA[i]);
 107          //    }
 108          //
 109          //    printf("\r\n");
 110          //}
 111          
 112          /* 设置调试标志位，将需要发送的数据 转发到uart */
 113          void Send(MsgStruct *SendMsg) {
 114   1          uint32 ID = SendMsg->ID;
 115   1          uint8 EXIDE = SendMsg->EXIDE;
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 3   

 116   1          uint8 DLC = SendMsg->DLC | (SendMsg->RTR << 6);
 117   1          CAN_Send_buffer(ID, EXIDE, DLC, SendMsg->DATA);
 118   1      }
 119          
 120          
 121          /*******************************************************************************
 122          * 描述    : 通过Can msg设置CAN配置,
 123          * data[0]保留标志位，
 124          * data[1]:addr, 2: data_len, [3:7]:data_arr
 125          * 说明    : 设置完成后需下发初始化使能信号。
 126          * 初步模块简单设置
 127          *******************************************************************************/
 128          void msg_set_E2(uint8 *msg_data) {
 129   1          uint8 i;
 130   1          uint8 addr = msg_data[1];
 131   1          uint8 len = msg_data[2];
 132   1          uint8 array[8];
 133   1          for (i = 0; i < len; i++) //发送字符串，直到遇到0才结束
 134   1              {
 135   2              array[i] = msg_data[i+3];
 136   2              }
 137   1          E2Write(array, addr, len + 3);
 138   1      }
 139          
 140          /*******************************************************************************
 141          * 描述    : 接收到信息后,根据状态进行反应
 142          * 输入    : msg
 143          * 说明    : 设计盲应答模式， 统一一个ID，上报和调试，方便查找设备
 144          *******************************************************************************/
 145          //void action_rec_msg(MsgStruct *RecMsg) {
 146          //    if (RecMsg->FILHIT == 0) {  // 滤波器0H 进行 配置信息
 147          //        if (RecMsg->DATA[0] == action_status) {
 148          //            // 设置主程序运行状态， 使能配置， 获取配置等
 149          //            main_status =RecMsg->DATA[1];
 150          //        } else if (RecMsg->DATA[0] == action_E2) {
 151          //            // 从rec中设置E2， config, 波特率只能通过E2写 的方式修改
 152          //            msg_set_E2(RecMsg->DATA);
 153          //        } else if (RecMsg->DATA[0] == action_MCP2515){  // 直接设置MCP2515寄存器
 154          //            // [0] 状态标志位， [1] addr, [2] data
 155          //            MCP2515_WriteByte(RecMsg->DATA[1], RecMsg->DATA[2]);
 156          //        }
 157          //    } else if (RecMsg->FILHIT == 1) {  // 滤波器1H 读取MCP2515数据
 158          //        if (RecMsg->DATA[0] == action_status) {
 159          //            // 读取主程序运行状态
 160          //            RecMsg->DLC = 1;
 161          //            RecMsg->DATA[0] == main_status;
 162          //        } else if (RecMsg->DATA[0] == action_E2) {
 163          //            // 从rec中设置E2， config
 164          //            RecMsg->DLC = RecMsg->DATA[2];
 165          //            E2Read(RecMsg->DATA, RecMsg->DATA[1], RecMsg->DATA[2]);  // 从 EEPROM 读取一段数据
 166          //            // 发送应答msg
 167          //        } else if (RecMsg->DATA[0] == action_MCP2515) {  // 直接读取MCP2515寄存器
 168          //            RecMsg->DLC = 1;
 169          //            RecMsg->DATA[0] == MCP2515_ReadByte(RecMsg->DATA[1]);
 170          //        }
 171          //        if (RecMsg->RTR  == 0) {
 172          //            // 如果是远程帧，说明是应答过的
 173          //            RecMsg->RTR = 1; // 应答模式设计为远程帧， 解决回环模式重复发送问题
 174          //            Send(&RecMsg);
 175          //        }
 176          //        Printf_Msg(&RecMsg);
 177          //    } else if (RecMsg->FILHIT == 5) {  // 滤波器5H 盲应答模式
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 4   

 178          //        return;
 179          //    } else {  // GPIO 设置
 180          //        return;
 181          //    }
 182          //}
 183          //
 184          ///* 将需要发送的数据 转发到uart, CAN_RX_Buf[14]*/
 185          //void Receive(uint8 RXB_CTRL_Address, MsgStruct *RecMsg) {
 186          //    uint8 i;
 187          //
 188          //    uint8 RXBnCTRL = MCP2515_ReadByte(RXB_CTRL_Address);
 189          //    uint8 RXBnDLC = MCP2515_ReadByte(RXB_CTRL_Address + 5);
 190          //    RecMsg->DLC = RXBnDLC & 0x0F;
 191          //    RecMsg->RTR = RXBnDLC >> 6;
 192          //
 193          //    if (RXB_CTRL_Address == RXB0CTRL) {
 194          //        RecMsg->FILHIT = RXBnCTRL & 0x3;
 195          //    } else {
 196          //        RecMsg->FILHIT = RXBnCTRL & 0x7;
 197          //    }
 198          //
 199          //    RecMsg->ID = Get_ID_For_Buf(RXB_CTRL_Address + 1);
 200          //    RecMsg->EXIDE = (MCP2515_ReadByte(RXB_CTRL_Address + 2) & 0x8) >> 3;
 201          //
 202          //    for (i = 0; i < RecMsg->DLC; i++) //获取接收到的数据
 203          //    {
 204          //        RecMsg->DATA[i] = MCP2515_ReadByte(RXB_CTRL_Address + 6 + i);
 205          //    }
 206          //    // 根据接收的msg, 进行动作
 207          //    action_rec_msg(&RecMsg);
 208          //}
 209          
 210          void printE2Write(uint8 *E2_data, uint8 add, uint8 Len) {
 211   1          uint8 i;
 212   1          printf("add: %02bX Len: %02bX Data:", add, Len);
 213   1          for (i = 0; i < Len; i++) //发送字符串，直到遇到0才结束
 214   1              {
 215   2              printf(" %02bX", E2_data[i]);
 216   2              }
 217   1          printf("\r\n");
 218   1      }
 219          
 220          // 本地调试使用
 221          void SaveCfgToE2(CanCfgStruct *CanCfg) {
 222   1          uint8 E2_data[8];
 223   1      //    uint8 read_data[8];
 224   1      printf("SaveCfgToE2  : %02bX \r\n", main_status);
 225   1          E2_data[E2_5Kbps] = CanCfg->_5Kbps;
 226   1          E2_data[E2_BUKT_enable] = CanCfg->BUKT_enable;
 227   1          E2_data[E2_RXB0RXM] = CanCfg->RXB0RXM;
 228   1          E2_data[E2_RXB1RXM] = CanCfg->RXB1RXM;
 229   1          E2_data[E2_CAN_MODE] = CanCfg->CAN_MODE;
 230   1          E2_data[E2_CANINTE_enable] = CanCfg->CANINTE_enable;
 231   1          E2_data[E2_CANINTF_enable] = CanCfg->CANINTF_enable;
 232   1      
 233   1          printf("SaveCfgToE2  : %02bX %02bX %02bX %02bX %02bX \r\n", E2_data[0], E2_data[1], E2_data[2], E2_dat
             -a[3]);
 234   1          E2Write(E2_data, E2_CanCifg, 7);
 235   1          printE2Write(E2_data, E2_CanCifg, 7);
 236   1      
 237   1          //  设置屏蔽器0 1
 238   1          Set_Array_For_ID(E2_data, 0, CanCfg->RXM0ID, 0);
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 5   

 239   1          Set_Array_For_ID(E2_data, 4, CanCfg->RXM1ID, 0);
 240   1          E2Write(E2_data, E2_RXM01ID, 8);
 241   1      //    printE2Write(E2_data, E2_RXM01ID, 8);
 242   1      
 243   1          // 滤波器0、1， 首位为扩展帧标志位
 244   1          Set_Array_For_ID(E2_data, 0, CanCfg->RXF0ID, CanCfg->RXF0IDE);
 245   1          Set_Array_For_ID(E2_data, 4, CanCfg->RXF1ID, CanCfg->RXF1IDE);
 246   1          E2Write(E2_data, E2_RXF01, 8);
 247   1      //    printE2Write(E2_data, E2_RXF01, 8);
 248   1      
 249   1          // 滤波器2、3
 250   1          Set_Array_For_ID(E2_data, 0, CanCfg->RXF2ID, CanCfg->RXF2IDE);
 251   1          Set_Array_For_ID(E2_data, 4, CanCfg->RXF3ID, CanCfg->RXF3IDE);
 252   1          E2Write(E2_data, E2_RXF23, 8);
 253   1      //    printE2Write(E2_data, E2_RXF23, 8);
 254   1      
 255   1          // 滤波器4、5
 256   1          Set_Array_For_ID(E2_data, 0, CanCfg->RXF4ID, CanCfg->RXF4IDE);
 257   1          Set_Array_For_ID(E2_data, 4, CanCfg->RXF5ID, CanCfg->RXF5IDE);
 258   1          E2Write(E2_data, E2_RXF45, 8);
 259   1      //    E2_data[0] = CanCfg->RXF4ID >> 24 | (CanCfg->RXF4IDE << 7);
 260   1      //    E2_data[1] = (CanCfg->RXF4ID >> 16) & 0xFF;
 261   1      //    E2_data[2] = (CanCfg->RXF4ID >> 8) & 0xFF;
 262   1      //    E2_data[3] = CanCfg->RXF4ID & 0xFF;
 263   1      //    E2_data[4] = (CanCfg->RXF5ID >> 24) | (CanCfg->RXF5IDE << 7);
 264   1      //    E2_data[5] = (CanCfg->RXF5ID >> 16) & 0xFF;
 265   1      //    E2_data[6] = (CanCfg->RXF5ID >> 8) & 0xFF;
 266   1      //    E2_data[7] = CanCfg->RXF5ID & 0xFF;
 267   1      //    E2Write(E2_data, E2_RXF45, 8);
 268   1      //    printE2Write(E2_data, E2_RXF45, 8);
 269   1      }
 270          
 271          //void Printf_E2(uint8 page) {
 272          //    uint8 i;
 273          //    uint8 E2_read_data[8];
 274          //    printf("page11: %02bX ", page);
 275          //    E2Read(E2_read_data, page, 8);
 276          //    for (i = 0; i < 8; i++) {
 277          //        printf(" %02bX ", E2_read_data[i]);
 278          //    }
 279          //    printf("\r\n");
 280          //}
 281          
 282          //void Printf_Cfg(CanCfgStruct *CanCfg) {
 283          ////    uint8 E2_read_data[8];
 284          ////    uint8 i;
 285          //    printf("page: ");
 286          //    Printf_E2(E2_CanCifg);
 287          //    Printf_E2(E2_RXF01);
 288          //    Printf_E2(E2_RXF23);
 289          //    Printf_E2(E2_RXF45);
 290          //
 291          ////    printf("_5Kbps: %02bX \r\n", CanCfg->_5Kbps);
 292          ////    printf("bitrate: %02bX %02bX %02bX %02bX %02bX\r\n", CanCfg->bitrate[0],
 293          ////           CanCfg->bitrate[1], CanCfg->bitrate[2], CanCfg->bitrate[3], CanCfg->bitrate[4]);
 294          ////
 295          ////    printf("BUKT_enable: %02bX \r\n", CanCfg->BUKT_enable);
 296          ////    printf("CAN_MODE: %02bX \r\n", CanCfg->CAN_MODE);
 297          ////
 298          ////    printf("CANINTE: %02bX \r\n", CanCfg->CANINTE_enable);
 299          ////    printf("CANINTF: %02bX \r\n", CanCfg->CANINTF_enable);
 300          ////
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 6   

 301          ////    printf("RXBnRXM0-1: %02bX %02bX\r\n", CanCfg->RXB0RXM, CanCfg->RXB1RXM);
 302          ////
 303          ////    printf("RXMnID0-1: %08lX %08lX\r\n", CanCfg->RXM0ID, CanCfg->RXM1ID);
 304          ////    printf("RXFnID0-5: %07lX %07lX %07lX %07lX %07lX\r\n", CanCfg->RXF0ID, CanCfg->RXF1ID, CanCfg->RXF
             -2ID,
 305          ////           CanCfg->RXF3ID, CanCfg->RXF4ID, CanCfg->RXF5ID);
 306          ////
 307          ////    printf("RXFnIDE0-5: %bX %bX %bX %bX %bX\r\n", CanCfg->RXF0IDE, CanCfg->RXF1IDE, CanCfg->RXF2IDE, C
             -anCfg->RXF3IDE,
 308          ////           CanCfg->RXF4IDE, CanCfg->RXF5IDE);
 309          //}
 310          
 311          ///*******************************************************************************
 312          //* 描述    : 将数组中的数据，拼接完整ID，长度取4
 313          //* 输入    : uint8 数组
 314          //* 说明    : 无
 315          //*******************************************************************************/
 316          //uint32 GetInt32FormE2(uint8 *buf, uint8 addr) {
 317          //    if (buf[1 + addr] & 0x8 >> 3) {
 318          //        uint32 SID = ((uint32) buf[0 + addr] << 3) | (buf[1 + addr] >> 5);
 319          //        uint32 EID = (uint32) (buf[1 + addr] & 3) << 16 | ((uint32) buf[2 + addr] << 8) | buf[3 + addr];
 320          //        return SID << 18 | EID;
 321          //    } else {
 322          //        uint32 SID = (uint32) (buf[0 + addr] << 3) | (buf[1 + addr] >> 5);
 323          //        return SID;
 324          //    }
 325          //}
 326          
 327          
 328          /*******************************************************************************
 329          * 描述    : 通过读取存储数据，设置Can配置
 330          * 输入    : Can配置结构体
 331          * 说明    : 依赖GetInt32FormE2拼接出完整ID， 首位做扩展标志位
 332          *******************************************************************************/
 333          void Set_Cfg_From_E2(CanCfgStruct *CanCfg) {
 334   1          uint8 E2_read_data[8];
 335   1      
 336   1          // page 0: Kbps, CAN_MODE, CANINTE, CANINTF, BUKT, RXB0RXM, RXB1RXM
 337   1          //  设置波特率
 338   1          E2Read(E2_read_data, E2_CanCifg, 8);  // 从 EEPROM 读取一段数据
 339   1          CanCfg->_5Kbps = E2_read_data[E2_5Kbps];
 340   1          Set_Bitrate_Array(CanCfg->_5Kbps, &(CanCfg->bitrate));
 341   1          CanCfg->CAN_MODE = E2_read_data[E2_CAN_MODE];      // 0:正常 1:休眠 2:环回 3:监听 4:配置
 342   1          CanCfg->CANINTE_enable = E2_read_data[E2_CANINTE_enable];
 343   1          CanCfg->CANINTF_enable = E2_read_data[E2_CANINTF_enable];
 344   1          //  设置滚存使能位、工作模式、中断使能位、中断标志位
 345   1          CanCfg->BUKT_enable = E2_read_data[E2_BUKT_enable];
 346   1          CanCfg->RXB0RXM = E2_read_data[E2_RXB0RXM];
 347   1          CanCfg->RXB1RXM = E2_read_data[E2_RXB1RXM];
 348   1      
 349   1          //  设置屏蔽器0 1
 350   1          E2Read(E2_read_data, E2_RXM01ID, 8);  // 从 EEPROM 读取一段数据
 351   1          CanCfg->RXM0ID = Get_ID_For_Array(E2_read_data, 0);
 352   1          CanCfg->RXM1ID = Get_ID_For_Array(E2_read_data, 4);
 353   1      
 354   1          //  滤波器0、1
 355   1          E2Read(E2_read_data, E2_RXF01, 8);  // 从 EEPROM 读取一段数据
 356   1          CanCfg->RXF0IDE = E2_read_data[1] & 0x8 >> 3;
 357   1          CanCfg->RXF0ID = Get_ID_For_Array(E2_read_data, 0);
 358   1          CanCfg->RXF1IDE = E2_read_data[4] & 0x8 >> 3;
 359   1          CanCfg->RXF1ID = Get_ID_For_Array(E2_read_data, 4);
 360   1          //  滤波器2、3
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 7   

 361   1          E2Read(E2_read_data, E2_RXF23, 8);  // 从 EEPROM 读取一段数据
 362   1          CanCfg->RXF2IDE = E2_read_data[0] & 0x8 >> 3;
 363   1          CanCfg->RXF2ID = Get_ID_For_Array(E2_read_data, 0);
 364   1          CanCfg->RXF3IDE = E2_read_data[4] & 0x8 >> 3;
 365   1          CanCfg->RXF3ID = Get_ID_For_Array(E2_read_data, 4);
 366   1          //  滤波器4、5
 367   1          E2Read(E2_read_data, E2_RXF45, 8);  // 从 EEPROM 读取一段数据
 368   1          CanCfg->RXF4IDE = E2_read_data[0] & 0x8 >> 3;
 369   1          CanCfg->RXF4ID = Get_ID_For_Array(E2_read_data, 0);
 370   1          CanCfg->RXF5IDE = E2_read_data[4] & 0x8 >> 3;
 371   1          CanCfg->RXF5ID = Get_ID_For_Array(E2_read_data, 4);
 372   1      }
 373          
 374          
 375          /*******************************************************************************
 376          * 描述    : 通过读取MCP2515寄存器，存储配置到E2
 377          * 输入    : 无
 378          * 说明    : 波特率配置数组默认采用树莓派上的组合，保留单位 5Kbps
 379          *******************************************************************************/
 380          void save_mcp2515_to_E2(void) {
 381   1          uint8 E2_data[8];
 382   1          uint8 i;
 383   1          uint8 offfset;
 384   1      
 385   1          uint8 tmp_data;
 386   1          uint8 EXIDE;
 387   1          uint32 ID;
 388   1          // 先读一次，保留波特率信息，波特率信息只能通过set-e2完成
 389   1          E2Read(E2_data, E2_CanCifg, 8);
 390   1      //    E2_data[E2_5Kbps] =  E2Read(E2_data, E2_CanCifg, 8)[0];
 391   1          tmp_data = MCP2515_ReadByte(RXB0CTRL);
 392   1          E2_data[E2_BUKT_enable] = tmp_data & 0x7 >> 2;
 393   1          E2_data[E2_RXB0RXM] = tmp_data & RXM >> 5;
 394   1          E2_data[E2_RXB1RXM] = MCP2515_ReadByte(RXB1CTRL) & RXM >> 5;
 395   1          E2_data[E2_CAN_MODE] = MCP2515_ReadByte(CANCTRL) & REQOP >> 5;
 396   1          E2_data[E2_CANINTE_enable] = MCP2515_ReadByte(CANINTE);
 397   1          E2_data[E2_CANINTF_enable] = MCP2515_ReadByte(CANINTF);
 398   1          E2Write(E2_data, E2_CanCifg, 7);
 399   1      
 400   1          // 保存滤波器0-5和屏蔽器0-1的ID，及扩展帧标志位
 401   1          for (i = 0; i < 8; i++)
 402   1          {
 403   2              offfset = tmp_data * 4;
 404   2              EXIDE = MCP2515_ReadByte(RXF0SIDL + offfset) & 0x8 >> 3;
 405   2              ID = Get_ID_For_Buf(RXF0SIDH + offfset);
 406   2              Set_Array_For_ID(E2_data, offfset % 8, ID, EXIDE);
 407   2      //        E2_data[0] = MCP2515_ReadByte(RXF0SIDH + tmp_data * 4);
 408   2      //        E2_data[1] = MCP2515_ReadByte(RXF0SIDL + tmp_data * 4);
 409   2      //        E2_data[2] = MCP2515_ReadByte(RXF0EID8 + tmp_data * 4);
 410   2      //        E2_data[3] = MCP2515_ReadByte(RXF0EID0 + tmp_data * 4);
 411   2              E2Write(E2_data, E2_RXF01 + offfset, 4);
 412   2          }
 413   1      }
 414          
 415          // 测试时使用
 416          //void SetCfg(CanCfgStruct *CanCfg)
 417          //{
 418          ////    printf("SetCfg  : %02bX \r\n", main_status);
 419          //    CanCfg->_5Kbps = 20;
 420          ////    printf("CanCfg->_5Kbps  : %02bX \r\n", CanCfg->_5Kbps);
 421          ////    {CAN_100Kbps,PRSEG_8TQ,PHSEG1_8TQ,PHSEG2_3TQ,SJW_1TQ}
 422          //    CanCfg->bitrate[0] = CAN_100Kbps;
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 8   

 423          //    CanCfg->bitrate[1] = PRSEG_8TQ;
 424          //    CanCfg->bitrate[2] = PHSEG1_8TQ;
 425          //    CanCfg->bitrate[3] = PHSEG2_3TQ;
 426          //    CanCfg->bitrate[4] = SJW_1TQ;
 427          ////    CanCfg->bitrate[0] = bitrate_100Kbps[0];
 428          ////    CanCfg->bitrate[1] = bitrate_100Kbps[1];
 429          ////    CanCfg->bitrate[2] = bitrate_100Kbps[2];
 430          ////    CanCfg->bitrate[3] = bitrate_100Kbps[3];
 431          ////    CanCfg->bitrate[4] = bitrate_100Kbps[4];
 432          //
 433          //    CanCfg->BUKT_enable = 1;
 434          //    CanCfg->CAN_MODE = 2;       // 000 = 设定为正常工作模式
 435          //                                // 001 = 设定为休眠模式
 436          //                                // 010 = 设定为环回模式
 437          //                                // 011 = 设定为仅监听模式
 438          //                                // 100 = 设定为配置模式
 439          //    CanCfg->CANINTE_enable = 3;
 440          //    CanCfg->CANINTF_enable = 0;
 441          //    CanCfg->RXM0ID = 0x1FFFFFFF;
 442          //    CanCfg->RXM1ID = 0x1FFFFFFF;
 443          //    printf("CanCfg->0RXM1ID  : %08bX \r\n", CanCfg->RXM1ID);
 444          //    CanCfg->RXF0ID = 0x100;
 445          //    printf("CanCfg->RXF0ID  : %08bX \r\n", CanCfg->RXF0ID);
 446          //    CanCfg->RXF1ID = 0x7FE;
 447          //    CanCfg->RXF2ID = 0x101;
 448          //    CanCfg->RXF3ID = 0x102;
 449          //    CanCfg->RXF4ID = 0x103;
 450          //    CanCfg->RXF5ID = 0x104;
 451          //
 452          //    CanCfg->RXF0IDE = 1;
 453          //    CanCfg->RXF1IDE = 0;
 454          //    CanCfg->RXF2IDE = 0;
 455          //    CanCfg->RXF3IDE = 1;
 456          //    CanCfg->RXF4IDE = 0;
 457          //    CanCfg->RXF5IDE = 1;
 458          ////    printf("CanCfg->RXF5ID  : %02bX \r\n", CanCfg->RXF5ID);
 459          //}
 460          
 461          //void ReadCfg(void) {
 462          //    printf("CNF1: %02bX ", MCP2515_ReadByte(CNF1));
 463          //    printf("CNF2: %02bX ", MCP2515_ReadByte(CNF2));
 464          //    printf("CNF3: %02bX \r\n", MCP2515_ReadByte(CNF3));
 465          //    printf("RXB0CTRL: %02bX ", MCP2515_ReadByte(RXB0CTRL));
 466          //    printf("CANINTF: %02bX ", MCP2515_ReadByte(CANINTF));
 467          //    printf("CANINTE: %02bX \r\n", MCP2515_ReadByte(CANINTE));
 468          //    printf("RXF0SIDH: %02bX ", MCP2515_ReadByte(RXF0SIDH));
 469          //    printf("RXF1SIDH: %02bX ", MCP2515_ReadByte(RXF1SIDH));
 470          //    printf("RXF2SIDH: %02bX \r\n", MCP2515_ReadByte(RXF2SIDH));
 471          //    printf("RXF3SIDH: %02bX ", MCP2515_ReadByte(RXF3SIDH));
 472          //    printf("RXF4SIDH: %02bX ", MCP2515_ReadByte(RXF4SIDH));
 473          //    printf("RXF5SIDH: %02bX \r\n", MCP2515_ReadByte(RXF5SIDH));
 474          //    printf("RXM0SIDH: %02bX ", MCP2515_ReadByte(RXM0SIDH));
 475          //    printf("RXM1SIDH: %02bX ", MCP2515_ReadByte(RXM1SIDH));
 476          //    printf("CANCTRL: %02bX \r\n", MCP2515_ReadByte(CANCTRL));
 477          //}
 478          
 479          /*******************************************************************************
 480          * 函数名  : 上电初始化程序
 481          * 描述    : 上电配置
 482          * 说明    : 设计上电自检程序，
 483          *******************************************************************************/
 484          void power_on_init(CanCfgStruct *CanCfg) {
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 9   

 485   1          //    MCP2515_Init(bitrate_100Kbps);
 486   1      //    printf("power_on_init: %02bX \r\n", main_status);
 487   1      //    SetCfg(&CanCfg);
 488   1      //    Printf_Msg(&RecMsg);
 489   1      //    printf("SetCfg: %02bX \r\n", main_status);
 490   1      //    SaveCfgToE2(&CanCfg);
 491   1          // page 0: Kbps, CAN_MODE, CANINTE, CANINTF, BUKT, RXB0RXM, RXB1RXM
 492   1      //    uint8 Send_data[8] = {0x14, 0x5, 0x03, 0x0, 0x01, 0x05, 0x03, 0x0};
 493   1      //    uint8 Send_data1[8] = {0x1F, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF};
 494   1      //    uint8 Send_data2[8] = {0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01};
 495   1      //    uint8 Send_data3[8] = {0x00, 0x00, 0x07, 0xff, 0x10, 0x00, 0x17, 0xFF};
 496   1      //    uint8 Send_data4[8] = {0x9F, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFE};
 497   1      //    E2Write(Send_data, E2_CanCifg, 7);
 498   1      //    E2Write(Send_data1, E2_RXM01ID, 8);
 499   1      //    // 1 100  0 101
 500   1      //    E2Write(Send_data2, E2_RXF01, 8);
 501   1      //    // 0 7FF  1 17FF
 502   1      //    E2Write(Send_data3, E2_RXF23, 8);
 503   1      //    // 1 1FFFFfFF  1 1FFFFfFE
 504   1      //    E2Write(Send_data4, E2_RXF45, 8);
 505   1      
 506   1      
 507   1          printf("SaveCfgToE2: %02bX \r\n", main_status);
 508   1      //    Set_Cfg_From_E2(&CanCfg);
 509   1      //    Printf_Cfg(&CanCfg);
 510   1          printf("Printf_Cfg: %02bX \r\n", main_status);
 511   1      //    Can_Init(&CanCfg);
 512   1      }
*** WARNING C280 IN LINE 484 OF main.c: 'CanCfg': unreferenced local variable
 513          
 514          void E2_buf(uint8 isRead)
 515          {
 516   1          uint8 Send_data[] = {
 517   1                  // 波特率, 工作模式, CANINTE, CANINTF, BUKT, RXB0RXM, RXB1RXM
 518   1                  0x14, 0x05, 0x03, 0x00, 0x01, 0x05, 0x03, 0x00,
 519   1                  // RXF0ID, 1 2 3   4 5    ExIDE   id
 520   1                  0x1F, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF,
 521   1                  0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01,
 522   1                  0x00, 0x00, 0x07, 0xff, 0x10, 0x00, 0x17, 0xFF,
 523   1                  // RXM0ID 0 1
 524   1                  0x9F, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFE};
 525   1          printf("E2_buf: %02bX ", isRead);
 526   1          if (isRead == 1) {
 527   2              E2Read(&Send_data, 0, 40);
 528   2              for (isRead = 0; isRead < 40; isRead++) {
 529   3                  if (isRead % 8 == 0) {
 530   4                      printf("\r\n");
 531   4                  }
 532   3                  printf(" %02bX ", Send_data[isRead]);
 533   3              }
 534   2          } else {
 535   2              E2Write(&Send_data, 0, 8);
 536   2          }
 537   1      
 538   1          printf("\r\n E2 end\r\n");
 539   1      //
 540   1      //
 541   1      //    if (isRead == 1) {
 542   1      //        for (i = 0; i < 8; i++)
 543   1      //        {
 544   1      //            offfset = tmp_data * 4;
 545   1      //            EXIDE = MCP2515_ReadByte(RXF0SIDL + offfset) & 0x8 >> 3;
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 10  

 546   1      //            ID = Get_ID_For_Buf(RXF0SIDH + offfset);
 547   1      //            Set_Array_For_ID(E2_data, offfset % 8, ID, EXIDE);
 548   1      //            //        E2_data[0] = MCP2515_ReadByte(RXF0SIDH + tmp_data * 4);
 549   1      //            //        E2_data[1] = MCP2515_ReadByte(RXF0SIDL + tmp_data * 4);
 550   1      //            //        E2_data[2] = MCP2515_ReadByte(RXF0EID8 + tmp_data * 4);
 551   1      //            //        E2_data[3] = MCP2515_ReadByte(RXF0EID0 + tmp_data * 4);
 552   1      //            E2Write(E2_data, E2_RXF01 + offfset, 4);
 553   1      //        }
 554   1      //    }
 555   1      }
 556          
 557          /*******************************************************************************
 558          * 描述    : 将can配置发送给系统
 559          * 说明    :　设计发送描述信息
 560          *******************************************************************************/
 561          void send_cfg(uint32 ID, uint8 flag, uint8 EXIDE, uint8 num, MsgStruct *SendMsg) {
 562   1          SendMsg->ID = ID;
 563   1          SendMsg->EXIDE = EXIDE;
 564   1          SendMsg->DATA[1] = flag;
 565   1          SendMsg->DATA[2] = num;
 566   1          Send(&SendMsg);
*** WARNING C182 IN LINE 566 OF main.c: pointer to different objects
 567   1      }
 568          
 569          /*******************************************************************************
 570          * 描述    : 将can配置发送给系统
 571          * 说明    : 设计发送描述信息
 572          *******************************************************************************/
 573          void send_can_cfg(CanCfgStruct *CanCfg, MsgStruct *SendMsg) {
 574   1          //　上电反馈，设计位远程帧，长度为7
 575   1          SendMsg->RTR = 0x1;
 576   1          SendMsg->DLC = 0;  // 初始设置位0，广播上电
 577   1          // 用第0个滤波器发送零长msg,通知上电
 578   1          SendMsg->ID = CanCfg->RXF0ID;
 579   1          SendMsg->EXIDE = CanCfg->RXF0IDE;
 580   1          Send(&SendMsg);
*** WARNING C182 IN LINE 580 OF main.c: pointer to different objects
 581   1      
 582   1          SendMsg->DLC = 7;
 583   1          SendMsg->DATA[0] = action_send_can_cfg;
 584   1          Set_Array_For_ID(&(SendMsg->DATA), 3, CanCfg->RXF0ID, CanCfg->RXF0IDE);
 585   1      
 586   1      //    SendMsg->DATA[3] = CanCfg->RXF0ID >> 24;
 587   1      //    SendMsg->DATA[4] = (CanCfg->RXF0ID >> 16) & 0xFF;
 588   1      //    SendMsg->DATA[5] = (CanCfg->RXF0ID >> 8) & 0xFF;
 589   1      //    SendMsg->DATA[6] = CanCfg->RXF0ID & 0xFF;
 590   1      
 591   1          send_cfg(CanCfg->RXF0ID, E2_5Kbps, CanCfg->RXF0IDE, CanCfg->_5Kbps, &SendMsg);
*** WARNING C182 IN LINE 591 OF main.c: pointer to different objects
 592   1          send_cfg(CanCfg->RXF0ID, E2_BUKT_enable, CanCfg->RXF0IDE, CanCfg->BUKT_enable, &SendMsg);
*** WARNING C182 IN LINE 592 OF main.c: pointer to different objects
 593   1          send_cfg(CanCfg->RXF0ID, E2_CAN_MODE, CanCfg->RXF0IDE, CanCfg->CAN_MODE, &SendMsg);
*** WARNING C182 IN LINE 593 OF main.c: pointer to different objects
 594   1          send_cfg(CanCfg->RXF0ID, E2_CANINTE_enable, CanCfg->RXF0IDE, CanCfg->CANINTE_enable, &SendMsg);
*** WARNING C182 IN LINE 594 OF main.c: pointer to different objects
 595   1          send_cfg(CanCfg->RXF0ID, E2_CANINTF_enable, CanCfg->RXF0IDE, CanCfg->CANINTF_enable, &SendMsg);
*** WARNING C182 IN LINE 595 OF main.c: pointer to different objects
 596   1      
 597   1          send_cfg(CanCfg->RXF1ID, E2_RXF0ID, CanCfg->RXF0IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 597 OF main.c: pointer to different objects
 598   1          send_cfg(CanCfg->RXF2ID, E2_RXF1ID, CanCfg->RXF1IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 598 OF main.c: pointer to different objects
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 11  

 599   1          send_cfg(CanCfg->RXF3ID, E2_RXF2ID, CanCfg->RXF2IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 599 OF main.c: pointer to different objects
 600   1          send_cfg(CanCfg->RXF4ID, E2_RXF3ID, CanCfg->RXF3IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 600 OF main.c: pointer to different objects
 601   1          send_cfg(CanCfg->RXF5ID, E2_RXF4ID, CanCfg->RXF4IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 601 OF main.c: pointer to different objects
 602   1          send_cfg(CanCfg->RXF5ID, E2_RXF5ID, CanCfg->RXF5IDE, 0, &SendMsg);
*** WARNING C182 IN LINE 602 OF main.c: pointer to different objects
 603   1          send_cfg(CanCfg->RXM0ID, E2_RXM0ID, 0, 0, &SendMsg);
*** WARNING C182 IN LINE 603 OF main.c: pointer to different objects
 604   1          send_cfg(CanCfg->RXM1ID, E2_RXM1ID, 0, 0, &SendMsg);
*** WARNING C182 IN LINE 604 OF main.c: pointer to different objects
 605   1      }
 606          
 607          /*******************************************************************************
 608          * 函数名  : main
 609          * 描述    : 主函数，用户程序从main函数开始运行
 610          * 输入    : 无
 611          * 输出    : 无
 612          * 返回值  : 无
 613          * 说明    : 设计串口调试模块
 614          *******************************************************************************/
 615          void main(void) {
 616   1          uint32 ID = 0x101;
 617   1          uint8 EXIDE = 0;
 618   1          uint8 DLC = 8;
 619   1          uint8 i;
 620   1      
 621   1      //    uint8 CANINTF_Flag;
 622   1      //    uint8 Send_data[] = {0x20, 0xF1, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07};
 623   1      //    uint8 E2_data[8];
 624   1      
 625   1      //    MsgStruct SendMsg;
 626   1      //    MsgStruct RecMsg;
 627   1      
 628   1          CanCfgStruct CanCfg;
 629   1      
 630   1          //    初始设置配置
 631   1          UART_init();    //UART1初始化配置
 632   1          Exint_Init();   //外部中断1初始化函数
 633   1          
 634   1          E2_buf(0);
 635   1          E2_buf(1);
 636   1      //    power_on_init(&CanCfg);
 637   1          while (1) {
 638   2              Delay_Nms(2000);
 639   2      //        switch (main_status) {
 640   2      //            case main_power_on:  // 上电自检
 641   2      //                printf("page1: %02bX %02bX ", main_status, main_power_on);
 642   2      //                power_on_init(&CanCfg);
 643   2      ////            case main_set_can_cfg: // 设置con config
 644   2      ////                Set_Cfg_From_E2(&CanCfg);
 645   2      ////                Can_Init(&CanCfg);
 646   2      ////            case main_send_can_cfg: // CAN发送当前配置，并打印
 647   2      ////                send_can_cfg(&CanCfg, &SendMsg);
 648   2      ////                Printf_Cfg(&CanCfg);     // 通过读取ＭＣＰ２５１５打印全部的配置信息
 649   2      ////                main_status = 0;  // 进入default模式
 650   2      ////                break;
 651   2      ////            case main_save_cfg:  // 将Config保持到E2中
 652   2      ////                save_mcp2515_to_E2();
 653   2      ////                break;
 654   2      //            default:  // 默认进入轮询等待
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 12  

 655   2      //                // 扫描GPIO，进入发送程序 scan_GPIO_chanage()
 656   2      //                // 扫描接收器状态，进入接收程序 scan_rec_chanage()
 657   2      //                break;
 658   2      //        }
 659   2          }
 660   1      
 661   1      
 662   1      //
 663   1      //    E2Write(Send_data, 0xF0, sizeof(Send_data));
 664   1      //    printf("Main Set");
 665   1      //    printE2Write(Send_data, 0xF0, sizeof(Send_data));
 666   1      //    E2Read(E2_data, E2_RXM01ID, sizeof(E2_data));  // 从 EEPROM 读取一段数据
 667   1      //    printf("Main Read ");
 668   1      //    printE2Write(E2_data, E2_RXM01ID, sizeof(E2_data));
 669   1      //    for (i = 0; i < 8; i++) //发送字符串，直到遇到0才结束
 670   1      //        {
 671   1      //        printf("读取数据 : E2_data[%bd] = %bx \r\n", i, E2_data[i]);
 672   1      //        }
 673   1      //    ReadCfg();
 674   1      //
 675   1      //    SendMsg.IsSend = 0x1;
 676   1      //
 677   1      //    SendMsg.ID = ID;
 678   1      //    SendMsg.TYPE = 0x2;
 679   1      //    SendMsg.EXIDE = 0x0;
 680   1      //    SendMsg.DLC = 8;
 681   1      //
 682   1      //    for (i = 0; i < 8; i++) //发送字符串，直到遇到0才结束
 683   1      //    {
 684   1      //        SendMsg.DATA[i] = Send_data[i];
 685   1      ////        printf("SendMsg.DATA[%bd] = %bx \r\n", i, SendMsg.DATA[i]);
 686   1      //    }
 687   1      //
 688   1      //    RecMsg.IsSend = 0;
 689   1      ////    Send(&SendMsg);
 690   1      //
 691   1      //    for (i = 0; i < 2; i++) //发送字符串，直到遇到0才结束
 692   1      //    {
 693   1      //        Send(&SendMsg);
 694   1      //        Printf_Msg(&SendMsg);
 695   1      //        SendMsg.ID = 0x100;
 696   1      //        SendMsg.TYPE = 0x2;
 697   1      //        SendMsg.EXIDE = 0x1;
 698   1      //        SendMsg.DLC = 7;
 699   1      //
 700   1      //        Delay_Nms(3000);
 701   1      //
 702   1      //        printf("CAN_RX0IF_Flag = %bd \r\n", CAN_RX0IF_Flag);
 703   1      //        printf("CAN_RX1IF_Flag = %bd \r\n", CAN_RX1IF_Flag);
 704   1      //        printf("CANSTAT: %02bX \r\n", MCP2515_ReadByte(CANSTAT));
 705   1      //
 706   1      //
 707   1      //        CANINTF_Flag = MCP2515_ReadByte(CANINTF);
 708   1      //        printf("CANINTF: %02bX \r\n", CANINTF_Flag);
 709   1      //
 710   1      //        if (CANINTF_Flag & RX0IF) {
 711   1      //            Receive(RXB0CTRL, &RecMsg);
 712   1      //            Printf_Msg(&RecMsg);
 713   1      //            MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFE);//清除中断标志位(中断标志寄存器
             -必须由MCU清零)
 714   1      //        }
 715   1      //
C51 COMPILER V9.60.0.0   MAIN                                                              11/20/2021 20:05:40 PAGE 13  

 716   1      //        if (CANINTF_Flag & RX1IF) {
 717   1      //            Receive(RXB1CTRL, &RecMsg);
 718   1      //            Printf_Msg(&RecMsg);
 719   1      //            MCP2515_WriteByte(CANINTF, MCP2515_ReadByte(CANINTF) & 0xFD);//清除中断标志位(中断标志寄存器
             -必须由MCU清零)
 720   1      //        }
 721   1      //    }
 722   1      //
 723   1      //    Delay_Nms(2000);
 724   1      //
 725   1      //    while (1) {
 726   1      //
 727   1      ////        if (CAN_RX0IF_Flag == 1)                            //接收缓冲器0 满中断标志位
 728   1      ////        {
 729   1      ////            CAN_RX0IF_Flag = 0;//CAN接收到数据标志
 730   1      ////            Receive(RXB0CTRL, RXB_Value);//CAN接收一帧数据
 731   1      ////            Delay_Nms(2000);  //移动到下一个字符
 732   1      ////
 733   1      ////        }
 734   1      ////        if (CAN_RX1IF_Flag == 1)                            //接收缓冲器1 满中断标志位
 735   1      ////        {
 736   1      ////            CAN_RX1IF_Flag = 0;//CAN接收到数据标志
 737   1      ////            CAN_Receive_Buffer(RXB1CTRL, RXB_Value);//CAN接收一帧数据
 738   1      //////            UART_send_buffer(RXB_Value, 14); //发送一个字符
 739   1      ////            Delay_Nms(2000);  //移动到下一个字符
 740   1      //////      UART_send_buffer(RXB_Value,14); //发送一个字符
 741   1      ////        }
 742   1      ////
 743   1      ////        Delay_Nms(2000);
 744   1      //    }
 745   1      
 746   1      }
*** WARNING C280 IN LINE 619 OF main.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 628 OF main.c: 'CanCfg': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3063    ----
   CONSTANT SIZE    =    228    ----
   XDATA SIZE       =      1     171
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  18 WARNING(S),  0 ERROR(S)
